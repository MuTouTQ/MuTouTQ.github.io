{"meta":{"title":"Terry_Tian's Code日志","subtitle":"行是知之始，知是行之成。","description":"在山的这边，海的那边，有一只程序猿。。。","author":"Terry Tian","url":"http://mutouspace.cn"},"pages":[{"title":"分类","date":"2017-02-17T07:17:36.000Z","updated":"2017-03-06T12:41:07.314Z","comments":false,"path":"categories/index.html","permalink":"http://mutouspace.cn/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2015-09-30T12:31:36.000Z","updated":"2017-03-06T12:43:43.913Z","comments":true,"path":"guestbook/index.html","permalink":"http://mutouspace.cn/guestbook/index.html","excerpt":"","text":"strong a { color: #747474; } .player { text-align: center; margin: .5em auto 0; width: 100%; max-width: 22em; } .player br { display: none; } .sign { text-align: right; font-style: italic; } #ds-recent-visitors { margin: 0; padding: 0; } #ds-recent-visitors div img { display: inline-block !important; width: 56px !important; height: 56px !important; border-radius: 50%; border: 1px solid #ddd; padding: 2px; box-shadow: 1px 1px 1px rgba(0,0,0, .15); } .article-entry img:first-child { display: block; } .article-entry span { font-family: Arial; } #ds-hot-posts { display: none; } 如果大家有什么想说的，可以在这里留言！ —— Terry_Tian, 2017年2月17日 最近访客："},{"title":"标签","date":"2017-02-17T07:17:36.000Z","updated":"2017-03-06T12:41:55.552Z","comments":false,"path":"tags/index.html","permalink":"http://mutouspace.cn/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2017-02-17T07:17:36.000Z","updated":"2017-03-07T03:05:41.099Z","comments":false,"path":"about/index.html","permalink":"http://mutouspace.cn/about/index.html","excerpt":"","text":"strong a { color: #747474; } .player { text-align: center; margin: .5em auto 0; width: 100%; max-width: 22em; } .player br { display: none; } .sign { text-align: right; font-style: italic; } #ds-recent-visitors { margin: 0; padding: 0; } #ds-recent-visitors div img { display: inline-block !important; width: 56px !important; height: 56px !important; border-radius: 50%; border: 1px solid #ddd; padding: 2px; box-shadow: 1px 1px 1px rgba(0,0,0, .15); } .article-entry img:first-child { display: block; } .article-entry span { font-family: Arial; } #ds-hot-posts { display: none; } 开博缘由: 通过写博客的方式，加深理解，显性化自己的隐性知识； 共享知识，吸引同好，交流进步。 欢迎交流: QQ：1015236187 Email:1015236187@qq.com CSDN：Terry_Tian Sina:Terry_Tian Github:MuTouTQ 最近访客："}],"posts":[{"title":"老程序员总结的20+条经验教训","slug":"老程序员总结的20-条经验教训","date":"2017-06-25T09:23:02.000Z","updated":"2017-06-25T09:33:26.203Z","comments":true,"path":"2017/06/25/老程序员总结的20-条经验教训/","link":"","permalink":"http://mutouspace.cn/2017/06/25/老程序员总结的20-条经验教训/","excerpt":"本文转载于：http://www.it-home.org/article-2576-1.html 开发1.从小事做起，然后再扩展无论是创建一个新的系统，还是添加功能到现有的系统中，我总是从一个简单到几乎没有任何所需功能的版本启动，然后再一步一步地解决问题，直到满意为止。我从来没有妄想过能够一步登天。相反，我一边开发一边学习，同时新掌握的信息还可以用于解决方案中。 我很喜欢John Gall的这句话：“复杂系统总是源于简单系统的演化。”","text":"本文转载于：http://www.it-home.org/article-2576-1.html 开发1.从小事做起，然后再扩展无论是创建一个新的系统，还是添加功能到现有的系统中，我总是从一个简单到几乎没有任何所需功能的版本启动，然后再一步一步地解决问题，直到满意为止。我从来没有妄想过能够一步登天。相反，我一边开发一边学习，同时新掌握的信息还可以用于解决方案中。 我很喜欢John Gall的这句话：“复杂系统总是源于简单系统的演化。” 2.一次只改变一件事当我们在开发时，碰到测试失败和功能无效的情况，如果你一次只研究一个问题，那将会更容易找到问题的关键。换言之，就是使用短迭代。必须确保这个问题解决之后，再转移到另一个问题上。这适用于向下提交。如果在你添加新功能之前需要先重构代码，那么先提交重构，然后再添加新的功能。 3.尽早地添加日志记录和错误处理在开发新系统时，我做的第一件事就是添加日志和错误处理，因为这两者从一开始就非常有用。如果系统不能照常工作，那么你就需要知道程序中发生了什么——这是日志的作用。错误处理也是如此——错误和异常越早处理越好。 4.每一行新代码必须至少执行一次在你真正完成一个功能之前，你必须对它进行测试。不然，你怎么知道它是不是按照你的想法在执行呢？通常情况下，最好的方法是通过自动测试，但并非总是如此。不过，不管怎么说，每一行新代码必须至少执行一次。 5.在整体测试之前先进行模块测试先进行部分模块测试可以节省时间。通常说来，我们在整合不同的模块时也会出现问题，例如模块之间的接口不匹配。但是如果我们能够信任各个组件的话，那么跟踪集成问题就会变得简单得多。 6.所有事情所花费的时间总是比你预期的要长特别是在编程中，即使一切进展顺利，我们也很难对功能所需的时间做出正确的预算。并且，开发软件时碰到各种意想不到的问题是非常常见的。 侯世达定律其实道出了真谛：做事所花费的时间总是比你预期的要长，即使你在预期中已经考虑了侯世达定律。 7.先了解现有的代码大多数的编码都需要以某种方式改变现有的代码。即使是新功能，也需要适应现有的程序。所以，在你加进去新的内容前，首先需要了解当前的解决方案。否则，你一不小心就很有可能会打破现有的功能。这意味着，阅读代码和编写代码都是必要的技能。这也是为什么看似微小的变化仍可能需要很长时间才能解决的原因之一——你首先必须了解上下文。 8.阅读和运行幸运的是，对于理解代码，我们有两种互补的方法。你可以阅读代码，也可以运行代码。运行代码的确是个非常棒的好方法。所以，请确保充分利用这两种方法。 故障排除9.bug总是难免的我不喜欢那些宣称软件开发可以“一蹴而就”的高谈阔论。不论你再怎么费尽心机，bug总是难免的。最好能够做成可以快速故障排除、修复bug和部署修复的系统。 10.解决故障报告每个开发人员都应该花时间去处理来自客户的故障报告，并修复bug。这能让你更好地理解客户的意图，明白如何使用系统，知道排除故障的难易程度，了解系统的设计情况。这也是为自己的开发成果负责的好方法。 11.重现问题修复bug的第一步就是重现问题。然后你得确保修复之后，问题能够彻彻底底地消失。这样一个简单的规则可以确保你不会误将非问题当作是问题，并确保解决方案真的能够奏效。 12.修复已知错误，然后再看看有没有遗漏的地方有时候，可能同时存在着几个不同的问题。它们之间的互相作用，可能会让你毫无头绪，束手无策。不要纠结于搞清楚发生了什么，先去解决所有已知的问题，然后再看看还有什么不对的地方。 13.没有巧合在测试和故障排除时，不要相信会出现什么巧合。就像你改变了定时器的值，那么就会改变系统重启的频率。所以一切都并非是巧合。添加新功能，另一个不相干的功能变慢了？这绝对不是巧合。相反，是你应该仔细调查的内容。 14.关联时间戳在故障排除时，事件的时间戳可以作为你的好帮手。寻找偶数增量。例如，如果系统重启了，并且刚刚发出过一个3000毫秒左右的请求，那么可能是触发了某个定时器，才导致出现重启的动作。 团队合作15.面对面的交流最有效当我们需要讨论如何解决问题时，那么面对面的交流比视频、打电话和电子邮件都要好。 16.橡皮鸭法遇到你绞尽脑汁也解决不了的问题时，不妨找一个同事，然后将问题解释给他们听。很多时候，当你在叙述时，即使你的同事一言不发，你可能也会突然灵光乍现找到问题的关键。 17.问问题阅读和运行代码往往非常有助于指出代码的目的和它的工作原理。但是如果你有机会咨询那些更为了解的人（例如原来的程序员），那么千万不要错过。 18.共享荣誉不要贪图荣誉，该是谁的就是谁的。例如：“Marcus想出了这个主意……”（如果真是他想的话），而不要说“我们想出的……”。 其他19.尝试如果你不知道某种编程语言功能的工作原理，那么不妨写一个小程序来理解它是如何工作的。这同样适用于测试你正在开发的系统。如果我将参数设置为-1，会发生什么？当我在重启系统时，如果服务当掉，会发生什么？以此来研究它的工作原理。 20.带着问题睡觉如果你正在解决一个很难的问题，那么不妨带着问题睡觉。有科学研究表明，这样做虽然你表明上并没有在主动思考，但你的潜意思却这么做了。其结果就是，第二天再去研究问题，解决方案已经呼之欲出了。 21.跳槽不要害怕跳槽。和不同的人共事，开发不同的产品，感受不同的公司文化是非常有意思的。 22.不断学习我们需要不断地学习和了解软件开发。你可以尝试不同的编程语言和工具，阅读软件开发的书籍，接受MOOC课程。相信我，量变才能达到质的飞跃，这些小小的学习积累，终有一天会大大地提高你的知识和能力。","categories":[{"name":"美文","slug":"美文","permalink":"http://mutouspace.cn/categories/美文/"}],"tags":[{"name":"转载","slug":"转载","permalink":"http://mutouspace.cn/tags/转载/"}]},{"title":"Android中布局保存成图片","slug":"Android中布局保存成图片","date":"2017-05-12T09:38:29.000Z","updated":"2017-05-12T09:53:15.704Z","comments":true,"path":"2017/05/12/Android中布局保存成图片/","link":"","permalink":"http://mutouspace.cn/2017/05/12/Android中布局保存成图片/","excerpt":"概述今天做的APP中的一个表单页面需要以后蓝牙连接打印设备后打印出来，当时想过要截屏，但想了一下截屏的话太麻烦，截屏的话是将手机的屏幕截取下来，包含很多无用的信息，所以这个想法就给pass掉了；后来又想到了转化为图片、PDF什么的，在网上搜索了一些相关信息后，发现还是将整个布局变成图片比较简单，并且也找到了一篇不错测教程，文末附有链接。","text":"概述今天做的APP中的一个表单页面需要以后蓝牙连接打印设备后打印出来，当时想过要截屏，但想了一下截屏的话太麻烦，截屏的话是将手机的屏幕截取下来，包含很多无用的信息，所以这个想法就给pass掉了；后来又想到了转化为图片、PDF什么的，在网上搜索了一些相关信息后，发现还是将整个布局变成图片比较简单，并且也找到了一篇不错测教程，文末附有链接。 实现流程以及实现代码设置权限&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt; 获取布局relativeLayout = (RelativeLayout) findViewById(R.id.layout_rl); 设置布局相关设置 // 获取图片某布局 relativeLayout.setDrawingCacheEnabled(true); relativeLayout.buildDrawingCache(); 获取图片final Bitmap bmp = relativeLayout.getDrawingCache(); // 获取图片 savePicture(bmp, &quot;test.jpg&quot;);// 保存图片 保存图片public void savePicture(Bitmap bm, String fileName) { Log.i(&quot;xing&quot;, &quot;savePicture: ------------------------&quot;); if (null == bm) { Log.i(&quot;xing&quot;, &quot;savePicture: ------------------图片为空------&quot;); return; } File foder = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/test&quot;); if (!foder.exists()) { foder.mkdirs(); } File myCaptureFile = new File(foder, fileName); try { if (!myCaptureFile.exists()) { myCaptureFile.createNewFile(); } BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(myCaptureFile)); //压缩保存到本地 bm.compress(Bitmap.CompressFormat.JPEG, 90, bos); bos.flush(); bos.close(); } catch (IOException e) { e.printStackTrace(); } Toast.makeText(this, &quot;保存成功!&quot;, Toast.LENGTH_SHORT).show(); } 释放资源relativeLayout.destroyDrawingCache(); 完整代码如下package com.adwan.savephototolocal; import android.graphics.Bitmap; import android.os.Environment; import android.os.Handler; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.RelativeLayout; import android.widget.Toast; import java.io.BufferedOutputStream; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; public class MainActivity extends AppCompatActivity { private RelativeLayout relativeLayout; private Handler mHandler = new Handler(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); relativeLayout = (RelativeLayout) findViewById(R.id.layout_rl); } public void save(View view) { initView(); } private void initView() { // 获取图片某布局 relativeLayout.setDrawingCacheEnabled(true); relativeLayout.buildDrawingCache(); mHandler.postDelayed(new Runnable() { @Override public void run() { // 要在运行在子线程中 final Bitmap bmp = relativeLayout.getDrawingCache(); // 获取图片 savePicture(bmp, &quot;test.jpg&quot;);// 保存图片 relativeLayout.destroyDrawingCache(); // 保存过后释放资源 } },100); } public void savePicture(Bitmap bm, String fileName) { Log.i(&quot;xing&quot;, &quot;savePicture: ------------------------&quot;); if (null == bm) { Log.i(&quot;xing&quot;, &quot;savePicture: ------------------图片为空------&quot;); return; } File foder = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/test&quot;); if (!foder.exists()) { foder.mkdirs(); } File myCaptureFile = new File(foder, fileName); try { if (!myCaptureFile.exists()) { myCaptureFile.createNewFile(); } BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(myCaptureFile)); //压缩保存到本地 bm.compress(Bitmap.CompressFormat.JPEG, 90, bos); bos.flush(); bos.close(); } catch (IOException e) { e.printStackTrace(); } Toast.makeText(this, &quot;保存成功!&quot;, Toast.LENGTH_SHORT).show(); } } 参考： http://www.jianshu.com/p/72242e612ecb#","categories":[{"name":"Android","slug":"Android","permalink":"http://mutouspace.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://mutouspace.cn/tags/Android/"}]},{"title":"RecyclerView的万能分割线","slug":"RecyclerView的万能分割线","date":"2017-05-09T13:27:55.000Z","updated":"2017-05-09T13:34:25.750Z","comments":true,"path":"2017/05/09/RecyclerView的万能分割线/","link":"","permalink":"http://mutouspace.cn/2017/05/09/RecyclerView的万能分割线/","excerpt":"","text":"使用方法：添加默认分割线：高度为2px，颜色为灰色mRecyclerView.addItemDecoration(new RecycleViewDivider(mContext, LinearLayoutManager.VERTICAL)); 添加自定义分割线：可自定义分割线drawablemRecyclerView.addItemDecoration(new RecycleViewDivider( mContext, LinearLayoutManager.VERTICAL, R.drawable.divider_mileage)); 添加自定义分割线：可自定义分割线高度和颜色mRecyclerView.addItemDecoration(new RecycleViewDivider( mContext, LinearLayoutManager.VERTICAL, 10, getResources().getColor(R.color.divide_gray_color))); 万能分割线登场：public class RecycleViewDivider extends RecyclerView.ItemDecoration { private Paint mPaint; private Drawable mDivider; private int mDividerHeight = 2;//分割线高度，默认为1px private int mOrientation;//列表的方向：LinearLayoutManager.VERTICAL或LinearLayoutManager.HORIZONTAL private static final int[] ATTRS = new int[]{android.R.attr.listDivider}; /** * 默认分割线：高度为2px，颜色为灰色 * * @param context * @param orientation 列表方向 */ public RecycleViewDivider(Context context, int orientation) { if (orientation != LinearLayoutManager.VERTICAL &amp;&amp; orientation != LinearLayoutManager.HORIZONTAL) { throw new IllegalArgumentException(&quot;请输入正确的参数！&quot;); } mOrientation = orientation; final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); a.recycle(); } /** * 自定义分割线 * * @param context * @param orientation 列表方向 * @param drawableId 分割线图片 */ public RecycleViewDivider(Context context, int orientation, int drawableId) { this(context, orientation); mDivider = ContextCompat.getDrawable(context, drawableId); mDividerHeight = mDivider.getIntrinsicHeight(); } /** * 自定义分割线 * * @param context * @param orientation 列表方向 * @param dividerHeight 分割线高度 * @param dividerColor 分割线颜色 */ public RecycleViewDivider(Context context, int orientation, int dividerHeight, int dividerColor) { this(context, orientation); mDividerHeight = dividerHeight; mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(dividerColor); mPaint.setStyle(Paint.Style.FILL); } //获取分割线尺寸 @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) { super.getItemOffsets(outRect, view, parent, state); outRect.set(0, 0, 0, mDividerHeight); } //绘制分割线 @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) { super.onDraw(c, parent, state); if (mOrientation == LinearLayoutManager.VERTICAL) { drawVertical(c, parent); } else { drawHorizontal(c, parent); } } //绘制横向 item 分割线 private void drawHorizontal(Canvas canvas, RecyclerView parent) { final int left = parent.getPaddingLeft(); final int right = parent.getMeasuredWidth() - parent.getPaddingRight(); final int childSize = parent.getChildCount(); for (int i = 0; i &lt; childSize; i++) { final View child = parent.getChildAt(i); RecyclerView.LayoutParams layoutParams = (RecyclerView.LayoutParams) child.getLayoutParams(); final int top = child.getBottom() + layoutParams.bottomMargin; final int bottom = top + mDividerHeight; if (mDivider != null) { mDivider.setBounds(left, top, right, bottom); mDivider.draw(canvas); } if (mPaint != null) { canvas.drawRect(left, top, right, bottom, mPaint); } } } //绘制纵向 item 分割线 private void drawVertical(Canvas canvas, RecyclerView parent) { final int top = parent.getPaddingTop(); final int bottom = parent.getMeasuredHeight() - parent.getPaddingBottom(); final int childSize = parent.getChildCount(); for (int i = 0; i &lt; childSize; i++) { final View child = parent.getChildAt(i); RecyclerView.LayoutParams layoutParams = (RecyclerView.LayoutParams) child.getLayoutParams(); final int left = child.getRight() + layoutParams.rightMargin; final int right = left + mDividerHeight; if (mDivider != null) { mDivider.setBounds(left, top, right, bottom); mDivider.draw(canvas); } if (mPaint != null) { canvas.drawRect(left, top, right, bottom, mPaint); } } } } 附：自定的drawable文件一份&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;size android:height=&quot;20dp&quot; /&gt; &lt;solid android:color=&quot;#ff992900&quot; /&gt; &lt;/shape&gt; 参考： RecyclerView的万能分割线","categories":[{"name":"Android","slug":"Android","permalink":"http://mutouspace.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://mutouspace.cn/tags/Android/"},{"name":"Recycle","slug":"Recycle","permalink":"http://mutouspace.cn/tags/Recycle/"}]},{"title":"Volley 请求返回数据中文出现乱码","slug":"Volley-请求返回数据中文出现乱码","date":"2017-05-09T13:08:08.000Z","updated":"2017-05-09T13:26:40.635Z","comments":true,"path":"2017/05/09/Volley-请求返回数据中文出现乱码/","link":"","permalink":"http://mutouspace.cn/2017/05/09/Volley-请求返回数据中文出现乱码/","excerpt":"最近遇到一个问题。具体内容是使用Volley联网请求一段json数据，用Postman工具获取返回数据也是正确的，在别人的电脑上也是正常的，返回数据header中编码格式也是utf-8.那么问题就出在volly这个工具类上了。 经过排查，发现问题确实出在volley的一个工具类上 。","text":"最近遇到一个问题。具体内容是使用Volley联网请求一段json数据，用Postman工具获取返回数据也是正确的，在别人的电脑上也是正常的，返回数据header中编码格式也是utf-8.那么问题就出在volly这个工具类上了。 经过排查，发现问题确实出在volley的一个工具类上 。 HttpHeaderParser.parseCharset(response.headers); 利用StringRequst请求，获取数据的是这个方法 @Override protected Response&lt;String&gt; parseNetworkResponse(NetworkResponse response) { String parsed; try { parsed = new String(response.data, HttpHeaderParser.parseCharset(response.headers)); } catch (UnsupportedEncodingException e) { parsed = new String(response.data); } return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response)); } 返回的是byte[]，byte[]转化为String需要指定编码格式。问题就是出现在这个编码格式上 /** * Returns the charset specified in the Content-Type of this header, * or the HTTP default (ISO-8859-1) if none can be found. */ public static String parseCharset(Map&lt;String, String&gt; headers) { String contentType = headers.get(HTTP.CONTENT_TYPE); if (contentType != null) { String[] params = contentType.split(&quot;;&quot;); for (int i = 1; i &lt; params.length; i++) { String[] pair = params[i].trim().split(&quot;=&quot;); if (pair.length == 2) { if (pair[0].equals(&quot;charset&quot;)) { return pair[1]; } } } } return HTTP.DEFAULT_CONTENT_CHARSET; } 这段代码会试图获取header中的编码格式。如果没获取到，就会返回默认的编码格式 iso.之所以出现乱码，就是因为返回了默认的编码iso，而没有正确的返回了header中包含的编码格式。 解决的办法很简单，就是重写 parseNetworkResponse(NetworkResponse response) 方法，手动的改为UTF-8编码 修改如下： @Override protected Response&lt;String&gt; parseNetworkResponse(NetworkResponse response) { String parsed; try { parsed = new String(response.data, &quot;UTF-8&quot;); } catch (UnsupportedEncodingException e) { parsed = new String(response.data); } return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response)); } 参考： Volley 请求返回数据中文出现乱码 volley 获取cookie总结","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://mutouspace.cn/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://mutouspace.cn/tags/JAVA/"},{"name":"Volley","slug":"Volley","permalink":"http://mutouspace.cn/tags/Volley/"}]},{"title":"java int类型转换成String,不足10位在前面补0","slug":"java-int类型转换成String-不足10位在前面补0","date":"2017-05-09T12:51:02.000Z","updated":"2017-05-09T13:02:22.090Z","comments":true,"path":"2017/05/09/java-int类型转换成String-不足10位在前面补0/","link":"","permalink":"http://mutouspace.cn/2017/05/09/java-int类型转换成String-不足10位在前面补0/","excerpt":"","text":"String.format(“%010d”, 25); 0代表前面要补的字符 10代表字符串长度 d表示参数为整数类型","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://mutouspace.cn/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://mutouspace.cn/tags/JAVA/"},{"name":"基础","slug":"基础","permalink":"http://mutouspace.cn/tags/基础/"}]},{"title":"Android卸载测试应用后再次安装应用失败","slug":"Android卸载测试应用后再次安装应用失败","date":"2017-05-03T04:19:12.000Z","updated":"2017-05-03T04:35:35.482Z","comments":true,"path":"2017/05/03/Android卸载测试应用后再次安装应用失败/","link":"","permalink":"http://mutouspace.cn/2017/05/03/Android卸载测试应用后再次安装应用失败/","excerpt":"","text":"感谢阅读这篇博文，欢迎关注与评论！大家在做Android开发时，可能碰到这样的情况：把手机上的测试APP卸载后，再次安装就安装不上了。（博主的手机是魅族MX5，以前的时候从未碰到这种情况。） 解决方法： 在手机与电脑正常连接的情况下，调出命令行窗口。 输入：adb uninstall 包名 如：adb uninstall com.hd.soft.tjg 按 回车键 后 提示 Success 后，一般就可以正常安装了！","categories":[{"name":"Android","slug":"Android","permalink":"http://mutouspace.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://mutouspace.cn/tags/Android/"}]},{"title":"JAVA学习之Struts2框架(二)","slug":"JAVA学习之Struts2框架-二","date":"2017-04-20T13:41:17.000Z","updated":"2017-04-20T13:56:25.710Z","comments":true,"path":"2017/04/20/JAVA学习之Struts2框架-二/","link":"","permalink":"http://mutouspace.cn/2017/04/20/JAVA学习之Struts2框架-二/","excerpt":"","text":"","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://mutouspace.cn/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://mutouspace.cn/tags/JAVA/"},{"name":"框架","slug":"框架","permalink":"http://mutouspace.cn/tags/框架/"},{"name":"Struts2","slug":"Struts2","permalink":"http://mutouspace.cn/tags/Struts2/"}]},{"title":"ADB的简单使用技巧（Android）","slug":"ADB命令简单使用技巧（Android）","date":"2017-04-16T12:52:52.000Z","updated":"2017-04-16T14:26:11.719Z","comments":true,"path":"2017/04/16/ADB命令简单使用技巧（Android）/","link":"","permalink":"http://mutouspace.cn/2017/04/16/ADB命令简单使用技巧（Android）/","excerpt":"感谢阅读这篇博文，欢迎关注与评论！ 连接手机和电脑的“脐带”，就是ADB——Android Debug Bridge。 ？？？？？此处为ADB的简单定义？？？？？？","text":"感谢阅读这篇博文，欢迎关注与评论！ 连接手机和电脑的“脐带”，就是ADB——Android Debug Bridge。 ？？？？？此处为ADB的简单定义？？？？？？ ADB基础ADB工具是位于SDK的`platfrom-tools`目录下，因此在命令行中使用ADB的时候，需要通过cd命令，切换到该目录下，或者将 platform-tools的路径添加到系统变量中，这样就可以直接使用了。配置好后，在命令行中输入以下命令。 如果显示如下内容，就说明配置成功了。 接着，在命令行中输入以下命令。 接下来就可以使用shell命令了。（不要问我这里Android这里为什么会出现shell，shell不是在Linux中的吗？因为Android就是就是Linux开发的！） ADB常用命令 显示系统中的全部Android平台 C：\\User\\Administrator&gt;android list targets 安装Apk程序（Install） adb install -r 应用程序.apk C：\\User\\Administrator&gt;adb install -r G:\\Test.apk 安装Apk程序（Push） adb push &lt;local&gt;&lt;remote&gt; C：\\User\\Administrator&gt;adb push G:\\Test.apk /system/app &gt; **区别:** 以上两种方法都可以将Apk安装到手机上，但也有不同。 1. adb Install 是将apk安装到 data/data 下，作为普通的用户应用程序。 2. adb push 不是安装命令，它是将一个文件写入到手机存储系统。因此，只要拥有相应的权限，就可以把任何apk放到任何目录下，甚至 放到System目录下，成为一个系统应用程序。 &gt; **adb push 补充：** 1. 向手机写入文件 adb push &lt;local&gt;&lt;remote&gt; C：\\User\\Administrator&gt;adb push G:\\Test.txt /system/temp/ 2. 从手机获取文件 adb push &lt;remote&gt;&lt;local&gt; C：\\User\\Administrator&gt;adb push /system/temp/ G:\\Test.txt 删除应用 adb remount （重新挂载系统分区，使系统分区重新可写） adb shell cd system/app rm *.apk 查看系统盘符 adb shell df 输出所有已经安装的应用 adb shell pm list packages -f 模拟按键输入 adb shell input keyevent C：\\User\\Administrator&gt;adb shell input keyevent 3 ps：82 menu 3 home 19 up 20 down 21 left 22 right 66 enter 4 back 模拟滑动输入 adb shell input touchscreen &lt;x1&gt;&lt;y1&gt;&lt;x2&gt;&lt;y2&gt; adb shell input touchscreen swipe 18 665 18 350 录制屏幕 adb shell screenrecord /sdcard/demo.mp4 重新启动 adb reboot 更多信息，大家可以去网上去查询！","categories":[{"name":"Android","slug":"Android","permalink":"http://mutouspace.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://mutouspace.cn/tags/Android/"},{"name":"ADB","slug":"ADB","permalink":"http://mutouspace.cn/tags/ADB/"}]},{"title":"JAVA学习之Struts2框架（一）","slug":"JAVA学习之Struts2框架","date":"2017-04-15T12:52:52.000Z","updated":"2017-04-16T08:37:10.324Z","comments":true,"path":"2017/04/15/JAVA学习之Struts2框架/","link":"","permalink":"http://mutouspace.cn/2017/04/15/JAVA学习之Struts2框架/","excerpt":"Struts2简介Struts2概述Struts2是Apache发行的MVC开源框架。注意：它只是表现层（MVC）框架。 Struts2的来历Struts1：也是apache开发的一套mvc的开源框架。在2005年之前非常流行。 弊端：Struts1的核心控制器就是一个Servlet。随着使用者的增多，弊端开始出现。 Struts2：在long long ago，有一个设计超前的框架XWork，后来推出了XWork1和WebWork2。Struts2就是apache和OpenSymphony组织合并开发出来。里面包含了WebWork2的核心及Struts的一些特性和功能。除此之外，和Struts1没有任何关系了。","text":"Struts2简介Struts2概述Struts2是Apache发行的MVC开源框架。注意：它只是表现层（MVC）框架。 Struts2的来历Struts1：也是apache开发的一套mvc的开源框架。在2005年之前非常流行。 弊端：Struts1的核心控制器就是一个Servlet。随着使用者的增多，弊端开始出现。 Struts2：在long long ago，有一个设计超前的框架XWork，后来推出了XWork1和WebWork2。Struts2就是apache和OpenSymphony组织合并开发出来。里面包含了WebWork2的核心及Struts的一些特性和功能。除此之外，和Struts1没有任何关系了。 搭建Struts2开发环境下载Struts2开发包官网：http://struts.apache.org 由于国内网络比较好，所以说可能有时候打不开，可以百度一下，下载一份。 开发包目录结构 搭建开发环境拷贝必要jar包到classpath中 拷贝哪些jar包？ 找到Struts2自带的例子中，struts-blank的war包，在它的\\WEB-INF\\lib目录下的jar包全拷贝。 建立Struts2的配置文件 at the top of classpath（在最顶层的构建路径）,建立一个默认名称为struts.xml的配置文件。 struts.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; &lt;struts&gt; &lt;/struts&gt; 注意： 文件名大小写。 创建位置。 该名称允许修改，但是我们一般不改。 配置控制器a、配置位置：在web.xml中 b、配置什么： struts2已经写好了的一个过滤器。 结论： struts2比struts1优秀的一个体现就是，它用了更为强大的过滤器作为控制器了。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt; &lt;display-name&gt;Struts2Template&lt;/display-name&gt; &lt;!-- 配置Struts核心控制器，就是一个过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 验证是否成功部署应用，启动Tomcat，不报错表示搭建成功。 第一个Struts2案例 以下步骤是日后实际开发中经常重复的。 建立一个jsp文件index.jsp &lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Struts入门案例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;${pageContext.request.contextPath}/hello.action&quot;&gt;访问Struts的第一个入门案例&lt;/a&gt; &lt;a href=&quot;${pageContext.request.contextPath}/hello&quot;&gt;访问Struts的第一个入门案例&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 在struts.xml文件中配置struts.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; &lt;struts&gt; &lt;package name=&quot;p1&quot; extends=&quot;struts-default&quot; &gt; &lt;!-- name:jsp对应的请求地址； class:指定一个动作类，在这里也就是给hello指定一个动作类 method: 对应hello要执行的方法。 --&gt; &lt;action name=&quot;hello&quot; class=&quot;cn.terry.web.action.HelloAction&quot; method=&quot;sayHello&quot;&gt; &lt;!-- 配置结果视图 --&gt; &lt;result name=&quot;success&quot;&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 建立动作类和动作方法HelloAction.java package cn.terry.web.action; public class HelloAction {//动作类 /** * 在动作类中的指定的动作方法 * 动作方法的书写要求： * 1、都是public的 * 2、返回值必须是一个String * 3、必须没有参数 * @return */ public String sayHello(){ System.out.println(&quot;HelloAction的sayHello方法执行了&quot;); return &quot;success&quot;;//与配置文件中result的name取值相对应 } } 结果视图页面success.jsp &lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt; &lt;!-- &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt; --&gt; &lt;/head&gt; &lt;body&gt; 操作成功 &lt;/body&gt; &lt;/html&gt; 测试：只要没有错误，这里就可以得到自己想要的结果。 关于struts.xml没有代码提示的问题分析原因：没有找到对应的dtd约束文件。 解决办法： 在网上找到struts的.dtd包，放到如图目录中，这个包在网上找就可以。 ok就可以了。 第一个案例的执行过程 Struts2的配置文件加载时机：当应用被tomcat加载的时候，struts2的配置文件就已经被加载过了。 加载顺序加载顺序：default.properties——struts-default.xml——plugins配置——struts.xml——struts.properties——web.xml 顺序配置文件名所在位置说明1default.propertiesstruts2-core-2.3.15.3.jar\\org\\apache\\struts2 不能修改2struts-default.xmlstruts2-core-2.3.15.3.jar 不能修改3strtuts-plugin.xml在struts2提供的插件jar包中 不能修改4struts.xml我们的应用中 我们修改的：推荐5struts.properties我们的应用中 我们修改的6web.xml我们的应用中 我们修改的，可以给过滤器配置参数 注意： 1、Struts2提供了两种配置的方式。一种是key=value的方式，即使用.properties文件。另一种是xml文件配置。我们推荐使用xml文件（它能描述层级关系）。 2、当多个配置文件中，有相同的参数，后面的会把前面的值给覆盖了。 Struts2框架提供的常量常用的常量常量定义在了default.properties配置文件中，体现形式都是key=value。所有的struts2应用都会用到这些常量。 常用的： 常量名常量值说明struts.i18n.encodingUTF-8应用中使用的编码struts.objectFactory.spring.autoWirename和spring框架整合有关struts.multipart.parser jakarta 指定文件上传用的组件struts.multipart.maxSize 2097152 文件上传总文件大小限制：2Mstruts.action.extension action 能进入Struts2框架内部的url地址后缀名。多个值用逗号分隔struts.enable.DynamicMethodInvocation false 是否允许动态方法调用struts.devMode false 是否是开发模式。开发模式：改了配置文件，不需要重启。输出更多的错误信息。开发阶段建议为true。struts.ui.theme xhtml 页面展示用的主题 在struts.xml中覆盖常量使用&lt;constant name=&quot;&quot; value=&quot;&quot;&gt;&lt;/constant&gt;元素进行覆盖 例如： &lt;!-- 修改struts中默认的后缀名 --&gt; &lt;constant name=&quot;struts.action.extension&quot; value=&quot;do&quot;&gt;&lt;/constant&gt; 创建struts.properties文件覆盖在应用的构建路径中创建一个struts.properties的文件。 struts.xml配置文件的主要元素package元素 属性： name：包的名称。必须写。且必须唯一。 extends：一般情况下需要继承struts-default包，但不是必须的。不过如果不继承的话，将无法使用struts2提供的核心功能。 struts-default.xml中定义着struts-default这个包。而struts-default.xml是在我们的struts.xml加载之前加载。 abstract：把包声明为抽象包，抽象包就是用来被继承的。只要是没有元素的包，就可以声明为抽象包。 namespace：名称空间。 `名称空间 + 动作名称 = 访问路径` struts.xml代码片段 &lt;!-- package元素：是定义一个struts的包，它是把配置文件按照面向对象的思想来管理。分模块开发。 name属性：包的名称。具有唯一性。 extends属性：指定当前包的父包。它是按照面向对象的思想管理的体现。 abstract属性：把包声明为一个抽象包。抽象包是用来被继承的。只有没有action元素的包才能被定义为抽象包。 namespace属性：名称空间。当指定了名称空间以后，访问路径就变成了： 访问路径 = 名称空间+动作名称。 当不指定该属性时，该属性有默认值，默认值是&quot;&quot;,不是&quot;/&quot;. --&gt; &lt;package name=&quot;p1&quot; extends=&quot;struts-default&quot; namespace=&quot;/user&quot;&gt; packege中的namespace详解 namespace的默认值： a.不写该属性 b.写了该属性，取值是一个&quot;&quot;.注意：默认值不是/ 动作类的搜索顺序： action元素 属性： name：动作名称 class：动作类全名。默认的动作类是：com.opensymphony.xwork2.ActionSupport,是在struts-default.xml中定义的,要想替换默认动作类：在应用的struts.xml中，package中加入： method：动作类中的方法名称。默认是public String execute(){} 要求： 1.public的 2.返回值必须是String 3.没有参数 struts.xml代码片段 &lt;!-- action元素：是用于定义动作名称，动作类和动作方法的映射。以及当出现不同情况时前往指定的结果视图。 name属性：动作名称。和jsp中请求的url中的名称对应起来。注意：此处不能写 .action class属性：指定的动作类。 method属性：动作类中的方法名称。默认是public String execute(){} 要求： 1.public的 2.返回值必须是String 3.没有参数 --&gt; &lt;action name=&quot;action1&quot; class=&quot;cn.terry.web.action.DemoAction1&quot; method=&quot;saveUser&quot;&gt; 动作类 a.方式一：动作类就是一个POJO（Plain Old Java Object 原始的java对象），非常简单的javabean。 b.方式二：动作类实现com.opensymphony.xwork2.Action接口。 常量：给动作方法返回值用的。用常量可以使你的应用规范和统一。 常量变量名 对应的值 说明SUCCESS success 动作方法执行一切OKERROR error 动作方法执行时遇到了异常INPUT input 回显LOGIN login 一般转向登陆页面NONE none 不转向任何的视图 c.方式三：动作类继承com.opensymphony.xwork2.ActionSupport 推荐使用 动作的访问 a.使用通配符： 升级版： 优先级：绝对匹配优先。使用通配符的按照在配置文件中的先后顺序进行匹配的。 b.动态方法调用 result元素 属性： name：逻辑视图的名称，对应着动作方法的返回值。默认值是success。 type：结果类型，指的就是用什么方式转到定义的页面。默认是dispatcher。 struts.xml &lt;!-- result元素：配置逻辑结果视图； name属性：逻辑视图的名称，对应着动作方法的返回值。默认值是success。 type：结果类型，指的就是用什么方式转到定义的页面。默认是dispatcher。 常用取值： dispatcher：(默认值) 使用请求转发，转向一个页面。 redirect： 使用重定向，转向一个页面。 --&gt; &lt;result name=&quot;success&quot;&gt;/success.jsp&lt;/result&gt; result元素中type的取值 常用结果类型介绍： dispatcher：(默认值)使用请求转发，转向一个页面。 redirect：使用重定向，转向一个页面。 redirectAction：注意：使用的是重定向。 a.重定向到另一个相同名称空间的动作。 b.重定向到不同名称空间的动作 chain：注意： 使用的是请求转发。 a.转发到另一个相同名称空间的动作。 b.请求转发到不同名称空间的动作","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://mutouspace.cn/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://mutouspace.cn/tags/JAVA/"},{"name":"框架","slug":"框架","permalink":"http://mutouspace.cn/tags/框架/"},{"name":"Struts2","slug":"Struts2","permalink":"http://mutouspace.cn/tags/Struts2/"}]},{"title":"JAVA学习之框架前述","slug":"JAVA学习之框架前述","date":"2017-04-15T09:50:03.000Z","updated":"2017-04-15T10:11:31.293Z","comments":true,"path":"2017/04/15/JAVA学习之框架前述/","link":"","permalink":"http://mutouspace.cn/2017/04/15/JAVA学习之框架前述/","excerpt":"本篇文章是对学习框架前的开题篇。 内容为： 框架概述 三层架构 控制器：MVC中的控制器 案例中的问题","text":"本篇文章是对学习框架前的开题篇。 内容为： 框架概述 三层架构 控制器：MVC中的控制器 案例中的问题 框架概述框架的意义与作用： 所谓框架，就是把一些繁琐的重复性代码封装起来，使程序员在编码中把更多的经历放到业务需求的分析和理解上面。 特点：封装了很多细节，程序员在使用的时候会非常简单。 三层架构 表现层：M model V view C control 业务层：service 持久层：dao data access object Struts2在三层架构中的位置是处于表现层。Struts2只是一个表现层框架。 控制器：MVC中的控制器MVC回顾M：Model 模型，封装数据。javabean V：view 视图，展示界面。jsp C：Controller 控制器，控制程序流程。Servlet Servlet和FilterServlet: Filter： 总结： Servlet能做的事情，过滤器也可以做到。并且过滤器比Servlet还多了一个放行的功能，因此过滤器比Servlet功能更为强大。结论就是：过滤器同样也适合做控制器。 案例中的问题 规律： 1. 获取请求正文，用户要做什么事情 2. 根据不同的请求，做出不同的判断 3. 执行具体的方法代码（*动作*） 4. 转向页面，展示给用户 缺陷： 1. 重复性劳动太多，具体的执行代码也有冗余代码。 2. 到底要做什么全是硬编码，像用户要做什么事情，对应执行什么代码，可以写在配置文件中。 3. 具体的代码方法放到了控制器中，过于臃肿。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://mutouspace.cn/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://mutouspace.cn/tags/JAVA/"},{"name":"框架","slug":"框架","permalink":"http://mutouspace.cn/tags/框架/"}]},{"title":"JAVA学习之常用的数据源配置","slug":"JAVA学习之常用的数据源配置","date":"2017-04-02T12:39:01.000Z","updated":"2017-04-15T09:43:46.202Z","comments":true,"path":"2017/04/02/JAVA学习之常用的数据源配置/","link":"","permalink":"http://mutouspace.cn/2017/04/02/JAVA学习之常用的数据源配置/","excerpt":"常用的数据源配置： DBCP C3P0 用JavaWeb服务器管理数据源：Tomcat","text":"常用的数据源配置： DBCP C3P0 用JavaWeb服务器管理数据源：Tomcat DBCP DBCP：Apache推出的Database Connection Pool 使用步骤： 添加jar包: commons-dbcp-1.4.jar commons-pool-1.5.6.jar (这两个jar包网上一搜有很多，如果找不到合适的，读者可以email我，我发给大家！) 添加属性资源文件 编写数据源工具类 简例架构： 添加属性资源文件： dbcpconfig.properties 注：这个文件也是去网上搜索，拿来直接用就可以了。 dbcpconfig.properties 连接设置 driverClassName=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/day16 username=root password= &lt;!-- 初始化连接 --&gt; initialSize=10 最大连接数量 maxActive=50 &lt;!-- 最大空闲连接 --&gt; maxIdle=20 &lt;!-- 最小空闲连接 --&gt; minIdle=5 &lt;!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 --&gt; maxWait=60000 JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：[属性名=property;] 注意：&quot;user&quot; 与 &quot;password&quot; 两个属性会被明确地传递，因此这里不需要包含他们。 connectionProperties=useUnicode=true;characterEncoding=utf8 指定由连接池所创建的连接的自动提交（auto-commit）状态。 defaultAutoCommit=true driver default 指定由连接池所创建的连接的只读（read-only）状态。 如果没有设置该值，则“setReadOnly”方法将不被调用。（某些驱动并不支持只读模式，如：Informix） defaultReadOnly= driver default 指定由连接池所创建的连接的事务级别（TransactionIsolation）。 可用值为下列之一：（详情可见javadoc。）NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE defaultTransactionIsolation=REPEATABLE_READ 编写数据源工具类 DBCPUtil.java package cn.terry.utils; import java.io.IOException; import java.security.spec.DSAGenParameterSpec; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.Properties; import javax.sql.DataSource; import org.apache.commons.dbcp.BasicDataSourceFactory; public class DBCPUtil { private static DataSource ds = null; static{ Properties prop = new Properties(); //根据DBCPUtil的classes的路径，加载配置文件 try { prop.load(DBCPUtil.class.getClassLoader().getResourceAsStream(&quot;dbcpconfig.properties&quot;)); ds = BasicDataSourceFactory.createDataSource(prop);//得到一个数据源 } catch (Exception e) { throw new ExceptionInInitializerError(&quot;初始化错误，请检查配置文件&quot;); } } public static Connection getConnection() { try { return ds.getConnection(); } catch (SQLException e) { throw new RuntimeException(&quot;服务器忙。。。&quot;); } } public static void release(Connection conn,Statement stmt,ResultSet rs){ //关闭资源 if(rs!=null){ try { rs.close(); } catch (Exception e) { e.printStackTrace(); } rs = null; } if(stmt!=null){ try { stmt.close(); } catch (Exception e) { e.printStackTrace(); } stmt = null; } if(conn!=null){ try { conn.close();//关闭 } catch (Exception e) { e.printStackTrace(); } conn = null; } } } testJDBC.java package cn.terry.test; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.SQLException; import org.junit.Test; import cn.terry.utils.DBCPUtil; public class testJDBC { @Test public void test1() { Connection conn = null; PreparedStatement ps = null; try { conn = DBCPUtil.getConnection(); ps = conn.prepareStatement(&quot;..&quot;); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); }finally { DBCPUtil.release(conn, ps, null); } } } C3P0这个是建立的java项目。 简例结构图： 使用步骤： 1、添加jar包 jar包也是去网上搜。 2、编写配置文件 c3p0-config.xml，放在classpath中，或classes目录中 c3p0-config.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;c3p0-config&gt; &lt;default-config&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/mytest&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxIdleTime&quot;&gt;30&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;100&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt; &lt;/default-config&gt; &lt;/c3p0-config&gt; 3、编写工具类： C3P0Util.java package cn.terry.utils; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import javax.sql.DataSource; import com.mchange.v2.c3p0.ComboPooledDataSource; public class C3P0Util { //得到一个数据源 private static DataSource dataSource = new ComboPooledDataSource(); //从数据源中得到一个连接对象 public static Connection getConnection(){ try { return dataSource.getConnection(); } catch (SQLException e) { throw new RuntimeException(&quot;服务器错误&quot;); } } public static void release(Connection conn,Statement stmt,ResultSet rs){ //关闭资源 if(rs!=null){ try { rs.close(); } catch (Exception e) { e.printStackTrace(); } rs = null; } if(stmt!=null){ try { stmt.close(); } catch (Exception e) { e.printStackTrace(); } stmt = null; } if(conn!=null){ try { conn.close();//关闭 } catch (Exception e) { e.printStackTrace(); } conn = null; } } } TestCRUD.java package cn.terry.utils; import java.sql.Connection; import java.sql.PreparedStatement; import org.junit.Test; public class TestCRUD { @Test public void testInsert(){ Connection conn = null; PreparedStatement ps = null; try { conn = C3P0Util.getConnection(); ps = conn.prepareStatement(&quot;insert into account(name,money) values(&apos;ggg&apos;,2000)&quot;); ps.executeUpdate(); } catch (Exception e) { e.printStackTrace(); }finally{ C3P0Util.release(conn, ps, null); } System.out.println(conn.getClass().getName()); } } 用JavaWeb服务器管理数据源：Tomcat开发JavaWeb应用，必须使用一个JavaWeb服务器，JavaWeb服务器都内置数据源。 Tomcat：（DBCP） 数据源只需要配置服务器即可。 配置数据源的步骤： 1、拷贝数据库连接的jar到tomcatlib目录下 2、配置数据源XML文件 (全局配置)如果把配置信息写在tomcat下的conf目录的context.xml中，那么所有应用都能使用此数据源。 1）在tomcat的conf文件夹下的context.xml配置文件中加入： &lt;Resource name=&quot;jndi/mybatis&quot; auth=&quot;Container&quot; type=&quot;javax.sql.DataSource&quot; driverClassName=&quot;com.mysql.jdbc.Driver&quot; url=&quot;jdbc:mysql://localhost:3306/appdb&quot; username=&quot;root&quot; password=&quot;123456&quot; maxActive=&quot;20&quot; maxIdle=&quot;10&quot; maxWait=&quot;10000&quot;/&gt; 2)在项目的web.xml中加入资源引用： &lt;resource-ref&gt; &lt;description&gt;JNDI DataSource&lt;/description&gt; &lt;res-ref-name&gt;jndi/mybatis&lt;/res-ref-name&gt; &lt;res-ref-type&gt;javax.sql.DataSource&lt;/res-ref-type&gt; &lt;res-auth&gt;Container&lt;/res-auth&gt; &lt;/resource-ref&gt; 其中res-ref-name值要和context.xml的name值一致。 3）jndi测试方法： public void testJNDI() throws NamingException, SQLException{ Context ctx = new InitialContext(); DataSource ds = (DataSource) ctx.lookup(&quot;java:comp/env/jndi/mybatis&quot;); Connection conn = ds.getConnection(); System.out.println(conn.isClosed()); } 4）在jsp中调用加载jndi方式，不可以直接用main方法测试，必须通过启动容器从jsp中调用： TestPageAccessURL test = new TestPageAccessURL(); test.testJNDI(); （局部配置1）如果是在当前应用的META-INF中创建context.xml, 编写数据源，那么只有当前应用可以使用。 1）在项目的META-INFO下面新建context.xml。加入： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;Context&gt; &lt;Resource name=&quot;jndi/mybatis&quot; auth=&quot;Container&quot; type=&quot;javax.sql.DataSource&quot; driverClassName=&quot;com.mysql.jdbc.Driver&quot; url=&quot;jdbc:mysql://localhost:3306/appdb&quot; username=&quot;root&quot; password=&quot;123456&quot; maxActive=&quot;20&quot; maxIdle=&quot;10&quot; maxWait=&quot;10000&quot;/&gt; &lt;/Context&gt; 其他配置同第一种方式。 局部配置2（不推荐）。 1）在tomcat的server.xml的标签内，添加： &lt;Context path=&quot;/demo_jndi&quot; docBase=&quot;/demo_jndi&quot;&gt; &lt;Resource name=&quot;jndi/mybatis&quot; type=&quot;javax.sql.DataSource&quot; driverClassName=&quot;com.mysql.jdbc.Driver&quot; maxIdle=&quot;2&quot; maxWait=&quot;5000&quot; username=&quot;root&quot; password=&quot;123456&quot; url=&quot;jdbc:mysql://localhost:3306/appdb&quot; maxActive=&quot;4&quot;/&gt; &lt;/Context&gt; 其他配置同第一种方式。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://mutouspace.cn/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://mutouspace.cn/tags/JAVA/"},{"name":"连接池","slug":"连接池","permalink":"http://mutouspace.cn/tags/连接池/"}]},{"title":"JAVA学习之Jsp","slug":"JAVA学习之Jsp","date":"2017-03-29T12:41:07.000Z","updated":"2017-04-15T09:23:31.278Z","comments":true,"path":"2017/03/29/JAVA学习之Jsp/","link":"","permalink":"http://mutouspace.cn/2017/03/29/JAVA学习之Jsp/","excerpt":"Jsp 简介 JSP全称是Java Server Pages，它和servle技术一样，都是SUN公司定义的一种用于开发动态web资源的技术。JSP实际上就是Servlet。 jsp = html + java html:静态内容 servlet：服务器端的小应用程序。适合编写java逻辑代码，如果编写网页内容–苦逼。 jsp:适合编写输出动态内容，但不适合编写java逻辑。","text":"Jsp 简介 JSP全称是Java Server Pages，它和servle技术一样，都是SUN公司定义的一种用于开发动态web资源的技术。JSP实际上就是Servlet。 jsp = html + java html:静态内容 servlet：服务器端的小应用程序。适合编写java逻辑代码，如果编写网页内容–苦逼。 jsp:适合编写输出动态内容，但不适合编写java逻辑。 jsp的原理 JSP 语法(3、6、9) 接下来就是JSP的3（jsp的3个指令）6（jsp的6个动作）9（jsp的9个内置对象）了，简称：三六九。 JSP的脚本 小脚本: &lt;% java代码 %&gt; 表达式: &lt;%= 2+3 %&gt; 等价于out.print(2+3); 声明: &lt;%! %&gt; 表示在类中定义全局成员，和静态块。 1、脚本程序的语法格式及示例： &lt;% 代码片段 %&gt; &lt;% out.println(&quot;Your IP address is &quot; + request.getRemoteAddr()); %&gt; 2、表达式示例： &lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;ISO-8859-1&quot;%&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;% Date date = new Date(); out.write(date.toLocaleString()); %&gt; &lt;/body&gt; &lt;/html&gt; 3、声明示例： 一个声明语句可以声明一个或多个变量、方法，供后面的Java代码使用。在JSP文件中，您必须先声明这些变量和方法然后才能使用它们。 &lt;%! int i = 0; %&gt; &lt;%! int a, b, c; %&gt; &lt;%! Circle a = new Circle(2.0); %&gt; JSP 指令（3）JSP中的三种指令标签： 指令 描述 page 定义网页依赖属性，比如脚本语言、error页面、缓存需求等等 include 包含其他文件 taglib 引入标签库的定义 Page指令 Page指令为容器提供当前页面的使用说明。一个JSP页面可以包含多个page指令。 Page指令的语法格式： &lt;%@ 指令名称 属性1=“属性值1” 属性2=“属性值2”。。。%&gt; 或者： &lt;%@ 指令名称 属性1=“属性值1”%&gt; &lt;%@ 指令名称 属性2=“属性值2”%&gt; 如： &lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt; 或者： &lt;%@ page language=&quot;java&quot; %&gt; &lt;%@ page import=&quot;java.util.*&quot; %&gt; 与Page指令相关的属性： 属性 描述buffer JSP中有javax.servlet.jsp.JspWriter输出字符流。指定out对象使用缓冲区的大小,默认是8kb.autoFlush 控制out对象的 缓存区contentType 指定当前JSP页面的MIME类型和字符编码，等同于response.setContextType(“text/html;charset=utf-8”);errorPage 指定当JSP页面发生异常时需要转向的错误处理页面isErrorPage 指定当前页面是否可以作为另一个JSP页面的错误处理页面，默认是false。extends 指定servlet从哪一个类继承import 导入要使用的Java类,和java代码中的import是一样的info 定义JSP页面的描述信息isThreadSafe 指定对JSP页面的访问是否为线程安全language 定义JSP页面所用的脚本语言，默认是Javasession 指定JSP页面是否使用session,默认值是trueisELIgnored 指定是否执行EL表达式isScriptingEnabled 确定脚本元素能否被使用pageEncoding 告诉JSP引擎要翻译的文件使用的编码 注： errorPage：errorPage=”/uri” 如果写“/”则代表当前应用的目录下，绝对路径。如果不写“/”则代表相对路径。 include指令 JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。 静态包含：把其它资源包含到当前页面中。 &lt;%@ include file=&quot;/include/header.jsp&quot; %&gt; 动态包含： &lt;jsp:include page=&quot;/include/header.jsp&quot;&gt;&lt;/jsp:include&gt; 两者的区别：翻译的时间段不同 前者：在翻译时就把两个文件合并 后者：不会合并文件，当代码执行到include时，才包含另一个文件的内容。 原则：能用静的就不用动的。 taglib指令作用：在JSP页面中导入JSTL标签库。替换jsp中的java代码片段。 &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; JSP 动作元素（6） 使用标签的形式来表示一段java代码。 &lt;jsp:include &gt; 动态包含 &lt;jsp:forward&gt; 请求转发 &lt;jsp:param&gt; 设置请求参数 &lt;jsp:useBean&gt; 创建一个对象 &lt;jsp:setProperty&gt; 给指定的对象属性赋值 &lt;jsp:getProperty&gt; 取出指定对象的属性值 动作元素(jsp:include) 动作元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。 语法格式如下： &lt;jsp:include page=&quot;相对 URL 地址&quot; flush=&quot;true&quot; /&gt; 属性 描述page 包含在页面中的相对URL地址。flush 布尔属性，定义在包含资源前是否刷新缓存区。 实例: date.jsp文件代码： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;p&gt; 今天的日期是: &lt;%= (new java.util.Date()).toLocaleString()%&gt; &lt;/p&gt; main.jsp文件代码： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;123&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;include 动作实例&lt;/h2&gt; &lt;jsp:include page=&quot;date.jsp&quot; flush=&quot;true&quot; /&gt; &lt;/body&gt; &lt;/html&gt; 动作元素(jsp:useBean)jsp:useBean动作最简单的语法为： &lt;!-- 模板 --&gt; &lt;jsp:useBean id=&quot;name&quot; class=&quot;package.class&quot; /&gt; &lt;!-- 示例 --&gt; &lt;jsp:useBean id=&quot;stu1&quot; class=&quot;com.itheima.entity.Student&quot;&gt;&lt;/jsp:useBean&gt; 注： class中填写的是Bean类的完整路径 id 为定义的的Bean变量名，如 Bean b = new Bean()中的b; 动作元素(jsp:setProperty) jsp:setProperty用来设置已经实例化的Bean对象的属性. &lt;jsp:setProperty property=&quot;name&quot; name=&quot;stu1&quot; value=&quot;jerry&quot;/&gt; jsp:setProperty动作有下面四个属性,如下表： 属性 描述name name属性是必需的。它表示要设置属性的是哪个Bean。property property属性是必需的。它表示要设置哪个属性。有一个特殊用法：如果property的值是”*”，表示所有名字和Bean属性名字匹配的请求参数都将被传递给相应的属性set方法。value value 属性是可选的。该属性用来指定Bean属性的值。字符串数据会在目标类中通过标准的valueOf方法自动转换成数字、boolean、Boolean、 byte、Byte、char、Character。例如，boolean和Boolean类型的属性值（比如”true”）通过 Boolean.valueOf转换，int和Integer类型的属性值（比如”42”）通过Integer.valueOf转换。 value和param不能同时使用，但可以使用其中任意一个。param param 是可选的。它指定用哪个请求参数作为Bean属性的值。如果当前请求没有参数，则什么事情也不做，系统不会把null传递给Bean属性的set方法。因此，你可以让Bean自己提供默认属性值，只有当请求参数明确指定了新值时才修改默认属性值。 动作元素(jsp:getProperty) jsp:getProperty动作提取指定Bean属性的值，转换成字符串，然后输出。 语法格式如下： &lt;jsp:getProperty property=&quot;name&quot; name=&quot;stu1&quot;/&gt; 下表是与getProperty相关联的属性： 属性 描述name 要检索的Bean属性名称。Bean必须已定义。property 表示要提取Bean属性的值 实例： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;useBean&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;Jsp 使用 JavaBean 实例&lt;/h2&gt; &lt;jsp:useBean id=&quot;test&quot; class=&quot;com.runoob.main.TestBean&quot; /&gt; &lt;jsp:setProperty name=&quot;test&quot; property=&quot;message&quot; value=&quot;教程...&quot; /&gt; &lt;p&gt;输出信息....&lt;/p&gt; &lt;jsp:getProperty name=&quot;test&quot; property=&quot;message&quot; /&gt; &lt;/body&gt; &lt;/html&gt; 动作元素(jsp:forward) jsp:forward动作把请求转到另外的页面。jsp:forward标记只有一个属性page。 语法格式如下所示： &lt;jsp:forward page=&quot;相对 URL 地址&quot; /&gt; 以下是forward相关联的属性： 属性 描述page page属性包含的是一个相对URL。page的值既可以直接给出，也可以在请求的时候动态计算，可以是一个JSP页面或者一个 Java Servlet. 实例date.jsp 文件代码如下： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;p&gt; 今天的日期是: &lt;%= (new java.util.Date()).toLocaleString()%&gt; &lt;/p&gt; main.jsp文件代码： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;forward 动作实例&lt;/h2&gt; &lt;jsp:forward page=&quot;date.jsp&quot; /&gt; &lt;/body&gt; &lt;/html&gt; JSP 隐式对象(9) JSP隐式对象是JSP容器为每个页面提供的Java对象，开发者可以直接使用它们而不用显式声明。JSP隐式对象也被称为预定义变量。 JSP所支持的九大隐式对象： 对象 描述request HttpServletRequest类的实例,它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, header, 和session数据的有用的方法。response HttpServletResponse类的实例，并提供了几个用于设置送回浏览器的响应的方法（如cookies,头信息等）。out PrintWriter类的实例，用于把结果输出至网页上session HttpSession类的实例,Session可以存贮用户的状态信息。application ServletContext类的实例，与应用上下文有关,有助于查找有关servlet引擎和servlet环境的信息。config ServletConfig类的实例,该对象用于存取servlet实例的初始化参数。pageContext PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问page 类似于Java类中的this关键字，表示从该页面产生的一个servlet实例。Exception Exception类的对象，代表发生错误的JSP页面中对应的异常对象 pageContext(重要):1、本身也是一个域对象：它可以操作其它三个域对象（request session application）的数据. 四大域对象PageContext : pageConext 存放的数据在当前页面有效。开发时使用较少。 ServletRequest: request 存放的数据在一次请求（转发）内有效。使用非常多。 HttpSession: session 存放的数据在一次会话中有效。使用的比较多。如：存放用户的登录信息，购物车功能。 ServletContext: application 存放的数据在整个应用范围内都有效。因为范围太大，应尽量少用。 EL表达式EL概述和基本语法 EL表达式：expression language 表达式语言 要简化jsp中java代码开发。 它不是一种开发语言，是jsp中获取数据的一种规范 基本语法如下： ${表达式} EL中的基础操作符操作符 描述. 访问一个Bean属性或者一个映射条目[] 访问一个数组或者链表的元素( ) 组织一个子表达式以改变优先级+ 加- 减或负* 乘/ or div 除% or mod 取模A?B:C 执行某种条件判断== or eq 测试是否相等!= or ne 测试是否不等&lt; or lt 测试是否小于&gt; or gt 测试是否大于&lt;= or le 测试是否小于等于&gt;= or ge 测试是否大于等于&amp;&amp; or and 测试逻辑与|| or or 测试逻辑或! or not 测试取反empty 测试是否空值 补： EL表达式中的empty运算符用于判断某个对象是否为null或””，结果为布尔类型，语法格式如下： ${empty var} 下列情况empty返回值为true。 var变量不存在，即没有定义，例如表达式${empty name},如果不存在 name 变量，就返回 true。 var变量的值为null，例如表达式 ${empty customer.name},如果customer.name的值为null，就返回true. var变量引用集合（Set、Map、List）类型对象，并且在集合对象中不包含任何元素。 防止HTML注入displayMessage.jsp &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;servlet/ResultServlet&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 留言： &lt;textarea rows=&quot;6&quot; cols=&quot;50&quot; name=&quot;message&quot;&gt;&lt;/textarea&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; ResultServlet.java package com.tq.servlet; import java.io.IOException; import java.io.PrintWriter; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class ResultServlet extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doPost(request,response); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(&quot;UTF-8&quot;); String name = request.getParameter(&quot;username&quot;); String message = request.getParameter(&quot;message&quot;); request.setAttribute(&quot;name&quot;, name); request.setAttribute(&quot;message&quot;, message); request.getRequestDispatcher(&quot;/result.jsp&quot;).forward(request, response); } } HTMLFilter.java package com.tq.util; public class HTMLFilter { public static String filter(String message){ if (message==null) { return (null); } char content[] = new char[message.length()]; message.getChars(0, message.length(), content, 0); StringBuffer result = new StringBuffer(content.length); for (int i = 0; i &lt; content.length; i++) { switch (content[i]) { case &apos;&lt;&apos;: result.append(&quot;&amp;lt;&quot;); break; case &apos;&gt;&apos;: result.append(&quot;&amp;gt;&quot;); break; case &apos;&amp;&apos;: result.append(&quot;&amp;amp;&quot;); break; case &apos;&quot;&apos;: result.append(&quot;&amp;quot;&quot;); break; default: result.append(content[i]); break; } } return (result.toString()); } } mytaglib.tld &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd&quot; version=&quot;2.0&quot;&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;function&lt;/short-name&gt; &lt;uri&gt;http://www.mutouspace.cn&lt;/uri&gt; &lt;function&gt; &lt;name&gt;filter&lt;/name&gt; &lt;function-class&gt; com.tq.util.HTMLFilter &lt;/function-class&gt; &lt;function-signature&gt; java.lang.String filter(java.lang.String) &lt;/function-signature&gt; &lt;/function&gt; &lt;/taglib&gt; result.jsp &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix = &quot;terry&quot; uri=&quot;http://www.mutouspace.cn&quot; %&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 用户名:${name}&lt;br&gt; 留言：${terry:filter(message)} &lt;/body&gt; &lt;/html&gt; JSP 标准标签库（JSTL）待补充。。。。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://mutouspace.cn/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://mutouspace.cn/tags/JAVA/"},{"name":"JSP","slug":"JSP","permalink":"http://mutouspace.cn/tags/JSP/"}]},{"title":"JAVA学习之Servlet","slug":"JAVA之Servlet","date":"2017-03-25T15:31:16.000Z","updated":"2017-04-15T09:25:40.638Z","comments":true,"path":"2017/03/25/JAVA之Servlet/","link":"","permalink":"http://mutouspace.cn/2017/03/25/JAVA之Servlet/","excerpt":"Servlet 简介 Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 Servlet 任务 读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。 读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。 处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。 发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。 发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。","text":"Servlet 简介 Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 Servlet 任务 读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。 读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。 处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。 发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。 发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。 Servlet 生命周期public class ServletDemo1 implements Servlet{ //Servlet生命周期方法 //实例化 //在Servlet第一次访问时调用 public ServletDemo1(){ System.out.println(&quot;*************ServletDemo1执行了***************&quot;); } //Servlet生命周期方法 //初始化 //在Servlet第一次访问时调用,在后续每次用户请求时不再调用 @Override public void init(ServletConfig arg0) throws ServletException { System.out.println(&quot;*************init执行了***************&quot;); } //Servlet生命周期方法 //服务 //每次访问时都调用 @Override public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException { System.out.println(&quot;*************service执行了***************&quot;); } //Servlet生命周期方法 //销毁 @Override public void destroy() { System.out.println(&quot;*************destroy执行了***************&quot;); } @Override public ServletConfig getServletConfig() { // TODO Auto-generated method stub return null; } @Override public String getServletInfo() { // TODO Auto-generated method stub return null; } } HTTP 状态码代码 消息 描述100 Continue 只有请求的一部分已经被服务器接收，但只要它没有被拒绝，客户端应继续该请求。101 Switching Protocols 服务器切换协议。200 OK 请求成功。201 Created 该请求是完整的，并创建一个新的资源。202 Accepted 该请求被接受处理，但是该处理是不完整的。203 Non-authoritative Information 204 No Content 205 Reset Content 206 Partial Content 300 Multiple Choices 链接列表。用户可以选择一个链接，进入到该位置。最多五个地址。301 Moved Permanently 所请求的页面已经转移到一个新的 URL。302 Found 所请求的页面已经临时转移到一个新的 URL。303 See Other 所请求的页面可以在另一个不同的 URL 下被找到。304 Not Modified 305 Use Proxy 306 Unused 在以前的版本中使用该代码。现在已不再使用它，但代码仍被保留。307 Temporary Redirect 所请求的页面已经临时转移到一个新的 URL。400 Bad Request 服务器不理解请求。401 Unauthorized 所请求的页面需要用户名和密码。402 Payment Required 您还不能使用该代码。403 Forbidden 禁止访问所请求的页面。404 Not Found 服务器无法找到所请求的页面。.405 Method Not Allowed 在请求中指定的方法是不允许的。406 Not Acceptable 服务器只生成一个不被客户端接受的响应。407 Proxy Authentication Required 在请求送达之前，您必须使用代理服务器的验证。408 Request Timeout 请求需要的时间比服务器能够等待的时间长，超时。409 Conflict 请求因为冲突无法完成。410 Gone 所请求的页面不再可用。411 Length Required “Content-Length” 未定义。服务器无法处理客户端发送的不带 Content-Length 的请求信息。412 Precondition Failed 请求中给出的先决条件被服务器评估为 false。413 Request Entity Too Large 服务器不接受该请求，因为请求实体过大。414 Request-url Too Long 服务器不接受该请求，因为 URL 太长。当您转换一个 “post” 请求为一个带有长的查询信息的 “get” 请求时发生。415 Unsupported Media Type 服务器不接受该请求，因为媒体类型不被支持。417 Expectation Failed 500 Internal Server Error 未完成的请求。服务器遇到了一个意外的情况。501 Not Implemented 未完成的请求。服务器不支持所需的功能。502 Bad Gateway 未完成的请求。服务器从上游服务器收到无效响应。503 Service Unavailable 未完成的请求。服务器暂时超载或死机。504 Gateway Timeout 网关超时。505 HTTP Version Not Supported 服务器不支持”HTTP协议”版本。 设置 HTTP 状态代码的方法序号 方法 &amp; 描述1 public void setStatus ( int statusCode )该方法设置一个任意的状态码。setStatus 方法接受一个 int（状态码）作为参数。如果您的反应包含了一个特殊的状态码和文档，请确保在使用 PrintWriter 实际返回任何内容之前调用 setStatus。2 public void sendRedirect(String url)该方法生成一个 302 响应，连同一个带有新文档 URL 的 Location 头。3 public void sendError(int code, String message)该方法发送一个状态码（通常为 404），连同一个在 HTML 文档内部自动格式化并发送到客户端的短消息。 HTTP 状态码实例// 扩展 HttpServlet 类 public class showError extends HttpServlet { // 处理 GET 方法请求的方法 public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 设置错误代码和原因 response.sendError(407, &quot;Need authentication!!!&quot; ); } // 处理 POST 方法请求的方法 public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } CookieCookie实例： public class Cookie01 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doPost(request, response); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { getCookie(request, response); } //通过Servlet获取Cookie private void getCookie(HttpServletRequest request, HttpServletResponse response) throws UnsupportedEncodingException { Cookie cookie = null; Cookie[] cookies = null; // 获取与该域相关的 Cookie 的数组 cookies = request.getCookies(); // 设置响应内容类型 response.setContentType(&quot;text/html;charset=UTF-8&quot;); if( cookies != null ){ for (int i = 0; i &lt; cookies.length; i++){ cookie = cookies[i]; if((cookie.getName( )).compareTo(&quot;name&quot;) == 0 ){ cookie.setMaxAge(0); response.addCookie(cookie); System.out.println(&quot;已删除的 cookie：&quot; + cookie.getName( )); } System.out.println(&quot;名称：&quot; + cookie.getName( ) + &quot;,&quot;); System.out.println(&quot;值：&quot; + URLDecoder.decode(cookie.getValue(), &quot;utf-8&quot;)); } } } //设置Cookie private void setCookie(HttpServletRequest request, HttpServletResponse response) throws UnsupportedEncodingException, IOException { // 为名字和姓氏创建 Cookie Cookie name = new Cookie(&quot;name&quot;, URLEncoder.encode(request.getParameter(&quot;name&quot;), &quot;UTF-8&quot;)); // 中文转码 Cookie url = new Cookie(&quot;url&quot;, request.getParameter(&quot;url&quot;)); // 为两个 Cookie 设置过期日期为 24 小时后 name.setMaxAge(60*60*24); url.setMaxAge(60*60*24); // 在响应头中添加两个 Cookie response.addCookie(name); response.addCookie(url); // 设置响应内容类型 response.setContentType(&quot;text/html;charset=UTF-8&quot;); System.out.println(request.getParameter(&quot;name&quot;)); System.out.println(request.getParameter(&quot;url&quot;) ); } } html文件： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=servlet/cookie01 method=&quot;GET&quot;&gt; 站点名 ：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;br /&gt; 站点 URL：&lt;input type=&quot;text&quot; name=&quot;url&quot; /&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 文件下载：java文件： import java.io.FileInputStream; import java.io.IOException; import java.io.PrintWriter; import java.net.URLEncoder; import javax.servlet.ServletException; import javax.servlet.ServletOutputStream; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * 文件下载 * @author tianq * */ public class ServletDemo5 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doPost(request,response); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //通过路径得到一个输入流 String path = this.getServletContext().getRealPath(&quot;WEB-INF/classes/美景.jpg&quot;); FileInputStream fis = new FileInputStream(path); //创建字节输出流 ServletOutputStream sos = response.getOutputStream(); //得到要下载的文件名 String fileName = path.substring(path.lastIndexOf(&quot;\\\\&quot;)+1); //设置文件名编码 fileName = URLEncoder.encode(fileName, &quot;UTF-8&quot;); //告知客户端下载 response.setHeader(&quot;content-disposition&quot;, &quot;attachment;filename=&quot;+fileName); response.setHeader(&quot;content-type&quot;, &quot;image/jpeg&quot;); //执行输出操作 int len = 1; byte[] b = new byte[1024]; while ((len=fis.read(b))!=-1) { sos.write(b, 0, len); } } }","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://mutouspace.cn/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://mutouspace.cn/tags/JAVA/"},{"name":"Servlet","slug":"Servlet","permalink":"http://mutouspace.cn/tags/Servlet/"}]},{"title":"常用工具的环境变量配置","slug":"常用工具的环境变量配置","date":"2017-03-24T09:34:56.000Z","updated":"2017-03-25T01:41:48.082Z","comments":true,"path":"2017/03/24/常用工具的环境变量配置/","link":"","permalink":"http://mutouspace.cn/2017/03/24/常用工具的环境变量配置/","excerpt":"本博文主要介绍一些工具安装后对环境变量的配置，本来不打算写这种博文的，这种博文在网上一搜一大把，但网络资源鱼龙混杂，有的教程可能并不适合自己的环境，所以就写了这样一篇环境配置的博文，既然写了，那以后再遇到环境配置的问题还会继续添加，如有错误，欢迎大家指出，谢谢！ 转载请注明：转载于Terry Tian的博客（www.mutouspace.cn）! date: 2017-03-24 17:34:56 JDK的环境变量配置 Tomcat的环境变量配置","text":"本博文主要介绍一些工具安装后对环境变量的配置，本来不打算写这种博文的，这种博文在网上一搜一大把，但网络资源鱼龙混杂，有的教程可能并不适合自己的环境，所以就写了这样一篇环境配置的博文，既然写了，那以后再遇到环境配置的问题还会继续添加，如有错误，欢迎大家指出，谢谢！ 转载请注明：转载于Terry Tian的博客（www.mutouspace.cn）! date: 2017-03-24 17:34:56 JDK的环境变量配置 Tomcat的环境变量配置 大家既然想找的是如何配置环境变量，那读者一定知道软件是如何下载、如何安装的，所以本文中就不再过多的介绍下载和安装过程了，重点记录一下环境变量的配置。作者环境：Windows 10 X64 JDK的环境变量配置 新建JAVA_HOME 新建CLASSPATH 编辑PATH 第一步：“我的电脑” -&gt; 右击 -&gt; “属性” -&gt; “高级系统设置” -&gt; “环境变量”; 第二步：新建JAVA_HOME 里边填入jdk的绝对地址： E:\\JAVA\\jdk 注意：最后不要加分号！！！！ 第三步：新建CLASSPATH 内容为： .;%JAVA_HOME%\\lib; 注意：不要忘记前面的“ .; ”！！！！ 第四步：编辑PATH 新加入： %JAVA_HOME%\\bin; 注意：每个路径之间都有分号！！！！ 第五步：在控制台页面分别输入 “java” “javac” “java -version” 做测试 补充： ‘JAVAC’ 不是内部或外部命令解决方法 链接：http://jingyan.baidu.com/article/1e5468f924210a484961b7f0.html Tomcat的环境变量配置 新建变量名：CATALINA_BASE，变量值：E:\\tomcat 新建变量名：CATALINA_HOME，变量值：E:\\tomcat 打开PATH，添加变量值：%CATALINA_HOME%\\lib;%CATALINA_HOME%\\bin; 有了JDK环境变量配置的经验，我相信大家对配置都已经轻车熟路了，这里就不配图了。 最后一步： 在CMD命令下输入命令：startup，出现如下对话框，表明服务启动成功。","categories":[{"name":"工具","slug":"工具","permalink":"http://mutouspace.cn/categories/工具/"}],"tags":[{"name":"环境变量配置","slug":"环境变量配置","permalink":"http://mutouspace.cn/tags/环境变量配置/"}]},{"title":"常用的专业搜索工具（分类)","slug":"常用的专业搜索工具（分类","date":"2017-03-24T09:34:09.000Z","updated":"2017-03-24T11:16:24.690Z","comments":true,"path":"2017/03/24/常用的专业搜索工具（分类/","link":"","permalink":"http://mutouspace.cn/2017/03/24/常用的专业搜索工具（分类/","excerpt":"本文基于大家日常上网的需要，分类整理了不同检索需求的工具，主要包括：电子书、图片、网盘、音乐、工作机会以及商品价格检索。","text":"本文基于大家日常上网的需要，分类整理了不同检索需求的工具，主要包括：电子书、图片、网盘、音乐、工作机会以及商品价格检索。 一、电子书检索1、鸠摩搜书 鸠摩搜书是一款非常棒的电子书搜索引擎。有了它，你可以轻易发现其他站点上的电子书资源。这样可以省去很多时间。 2、BOOKZZ/Library Genesis 值得一提的是，这两个网站都可以不用翻墙，所以墙里的同学，也可以享受到来自世界的福利。 这两款可以说是英文教材资源站的神器了。 基本上，你想要的，它俩都能给你。 其他的电子书资源站点收录如下（含国内和国外）： 1、电子书网站汇总 注：这个是电子书资源汇总终极站，资源丰富的丧心病狂！ 二、图片检索1、多搜搜：www.duososo.com 2、原寸画像检索：gensun.org 3、incogna：www.incogna.com 4、百度识图 支持一下百度同学，毕竟国产 三、网盘资源检索：1、胖次搜索 胖次搜索 胖次搜索是一个很有意思的网盘资源搜索引擎，可以解析被吞的百度云分享链接。 2、百度网盘搜索 百度网盘是比百度本身更靠谱的搜索工具。 其他的网盘搜索引擎收录如下： 1、盘搜：www.pansou.com 2、西林街：www.xilinjie.com 3、盘易搜：panyisou.com 4、麦库搜索：www.baidu10.net 5、云搜：www.daysou.com 6、找文件：www.zhaofile.com 7、360搜网盘www.360swp.com 8、尝鲜搜索：search.likebeta.com 9、吸盘：so.xpan.me/index.html 10、去转盘：www.quzhuanpan.com 四、音乐检索作为网易云的忠实拥簇，一般来说，刷刷评论区，随机听一听FM，再收一收网易的推荐，基本上我的音乐边界就可以触到了。 然而，对于那些视音乐为生命的乐迷来说，世界上的好音乐总是不嫌多的。 有什么办法可以找到更丰富的音乐资源，享受更极致的音乐体验呢？ 下面的音乐检索工具，相信你一定不会错过。 1、Listen 1 音乐播放器 Listen 1 音乐播放器 Listen 1是一款搜索与播放来自网易云音乐，虾米，QQ音乐三个主流音乐网站的曲库软件。 这款软件的作用不言而喻，可以帮你减少在不同音乐站点搜索资源的时间花费。 软件本身支持windows、linux、MAC以及chrome和firefox的插件。 对多平台的支持，大大提高了普适性。 其他的音乐搜索工具收录如下： 1、Last.fm - 通过网上最大的音乐库收听免费音乐、观赏精彩视频 2、www.midomi.com 3、www.bored.com 4、www.sogua.com 五、职位搜索引擎按理说，职位搜索引擎是一个鸡肋般的存在。 因为国内的一些主流的招聘网站，基本上能够满足我们的需求。 智联、前程自不必说，拉勾、脉脉、boss直聘、猎聘、领英等，基本上就可以搞定我们的95%网络求职的需求。 一些垂着的，比如topys、站酷、秒聘，甚至水木社区招聘、itpub、豆瓣招聘小组等，都可以获得丰富的招聘机会。 因此机会从来不缺，但是我们缺一个获取机会的最快捷径。 这时候，一款合适的搜索引擎工具，就显得尤为重要了。 下面来分享几款较好的搜索引擎工具。 1、百度招聘 通过职位关键词，你可以找到大量的国内主流招聘网站发布的求职机会。 比如，前程、智联、拉勾、boss直聘等。 这样做的好处是明显的，不用疲于奔命，可以有效降低时间成本。 2、伯益 ：www.boryi.com 六、价格检索现在市场上的产品信息实在是太多太杂。 因为缺乏一个共同的标准，所以我们在购物的时候，总是满怀感叹：为什么同一件商品会有不同的价格。 这里面除了促销、进货成本的因素，平台本身也是一个很大的影响因子。 为了消除价格信息不对称引起的无效浪费， 我们需要一些有用的比价工具。 下面就是一些有效的比价网站。 1、比一比价 比一比价网是一款非常不错的购物价格搜索引擎。 主要检索各个购物网站同类商品的价格。比如京东、天猫、1号店、亚马逊、当当等。 网站主要支持关键词搜索，可以横向对比商品在各渠道的价格分布。 图书比价功能也很不错，堪比枣书。 2、历史价格检索 西贴真是一个神奇的网站。 作为一个商品历史价格查询器，西贴可以监控到某个商品的历史价格分布。 细心观察网站提供的价格变化曲线，我们可以发现一些不为察觉的价格猫腻。 若是放在双十一前后，大家是不是会忍住剁手的欲望？ 其他的价格检索收录如下： 1、Tangou：www.tangou.cn 2、寻购网：go.xungou.com 3、惠惠网 ：www.huihui.cn 写在最后： 适合自己的才是最好的！","categories":[{"name":"分享","slug":"分享","permalink":"http://mutouspace.cn/categories/分享/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://mutouspace.cn/tags/分享/"}]},{"title":"JAVA学习之JDBC","slug":"JAVA学习之JDBC","date":"2017-03-22T14:33:39.000Z","updated":"2017-07-13T08:58:14.783Z","comments":true,"path":"2017/03/22/JAVA学习之JDBC/","link":"","permalink":"http://mutouspace.cn/2017/03/22/JAVA学习之JDBC/","excerpt":"JDBC概述 JDBC:java database connectivity SUN公司提供的一套操作数据库的标准规范。 JDBC与数据库驱动的关系：接口与实现的关系。 JDBC规范（掌握四个核心对象）： DriverManager:用于注册驱动 Connection: 表示与数据库创建的连接 Statement: 操作数据库sql语句的对象 ResultSet: 结果集或一张虚拟表","text":"JDBC概述 JDBC:java database connectivity SUN公司提供的一套操作数据库的标准规范。 JDBC与数据库驱动的关系：接口与实现的关系。 JDBC规范（掌握四个核心对象）： DriverManager:用于注册驱动 Connection: 表示与数据库创建的连接 Statement: 操作数据库sql语句的对象 ResultSet: 结果集或一张虚拟表 开发一个JDBC程序（重要） 创建数据库表，并向表中添加测试数据 &lt;--创建数据库--&gt; create database mytest1; use mytest1; &lt;--创建数据库表--&gt; create table users( id int primary key auto_increment, name varchar(40), password varchar(40), email varchar(60), birthday date )character set utf8 collate utf8_general_ci; &lt;--添加数据--&gt; insert into users(name,password,email,birthday) values(&apos;zs&apos;,&apos;123456&apos;,&apos;zs@sina.com&apos;,&apos;1980-12-04&apos;); insert into users(name,password,email,birthday) values(&apos;lisi&apos;,&apos;123456&apos;,&apos;lisi@sina.com&apos;,&apos;1981-12-04&apos;); insert into users(name,password,email,birthday) values(&apos;wangwu&apos;,&apos;123456&apos;,&apos;wangwu@sina.com&apos;,&apos;1979-12-04&apos;); 创建java project项目，添加数据库驱动（*.jar） 实现JDBC操作 - 注册驱动 - 创建连接 - 得到执行sql语句的Statement对象 - 执行sql语句，并返回结果 - 处理结果 - 关闭资源 example: public class demo01 { public static void main(String[] args) throws Exception{ // TODO Auto-generated method stub //1、注册驱动 //DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //1.加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2、创建连接 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mytest1&quot;, &quot;root&quot;, &quot;root&quot;); //3、得到执行sql语句的Statement对象 Statement stmt = conn.createStatement(); //4、执行sql语句，并返回结果 String sql = &quot;select id,name,password,email,birthday from users&quot;; ResultSet rs = stmt.executeQuery(sql); //5、处理结果 while (rs.next()) { System.out.println(rs.getObject(1)); System.out.println(rs.getObject(2)); System.out.println(rs.getObject(3)); System.out.println(rs.getObject(4)); System.out.println(rs.getObject(5)); } //6关闭资源 rs.close(); stmt.close(); conn.close(); } } JDBC常用的类和接口详解java.sql.Drivermanager类 : 创建连接 注册驱动 DriverManager.registerDriver(new com.mysql.jdbc.Driver());不建议使用原因有2个： 导致驱动被注册2次。 强烈依赖数据库的驱动jar 解决办法： 用Class.forName(&quot;com.mysql.jdbc.Driver&quot;);代替。 与数据库建立连接 static Connection getConnection(String url, String user, String password) getConnection(&quot;jdbc:mysql://localhost:3306/mytest1&quot;, &quot;root&quot;, &quot;root&quot;); URL:SUN公司与数据库厂商之间的一种协议。 jdbc:mysql://localhost:3306/day06 协议 子协议 IP:端口号 数据库 mysql: jdbc:mysql://localhost:3306/day14 或者 jdbc:mysql:///day14（默认本机连接） oracle: jdbc:oracle:thin:@localhost:1521:sid Properties info = new Properties();//要参考数据库文档 info.setProperty(&quot;user&quot;, &quot;root&quot;); info.setProperty(&quot;password&quot;,&quot;root&quot;); getConnection(String url, Properties info) getConnection(String url) DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/day14?user=root&amp;password=root&quot;); 实现一个用户登录的功能Demo:https://github.com/MuTouTQ/login","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://mutouspace.cn/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://mutouspace.cn/tags/JAVA/"},{"name":"JDBC","slug":"JDBC","permalink":"http://mutouspace.cn/tags/JDBC/"}]},{"title":"JAVA学习之JUnit","slug":"JAVA学习之JUnit","date":"2017-03-22T14:33:06.000Z","updated":"2017-03-23T06:04:28.077Z","comments":true,"path":"2017/03/22/JAVA学习之JUnit/","link":"","permalink":"http://mutouspace.cn/2017/03/22/JAVA学习之JUnit/","excerpt":"JUnit是什么？ JUnit是用于编写和运行可重复的自动化测试的开源测试框架， 这样可以保证我们的代码按预期工作。 JUnit可广泛用于工业和作为支架(从命令行)或IDE(如Eclipse)内单独的Java程序。","text":"JUnit是什么？ JUnit是用于编写和运行可重复的自动化测试的开源测试框架， 这样可以保证我们的代码按预期工作。 JUnit可广泛用于工业和作为支架(从命令行)或IDE(如Eclipse)内单独的Java程序。 JUnit提供 断言测试预期结果。 测试功能共享通用的测试数据。 测试套件轻松地组织和运行测试。 图形和文本测试运行。 JUnit用于测试 整个对象 对象的一部分 - 交互的方法或一些方法 几个对象之间的互动(交互) JUnit的特点 JUnit是用于编写和运行测试的开源框架。 提供了注释，以确定测试方法。 提供断言测试预期结果。 提供了测试运行的运行测试。 JUnit测试让您可以更快地编写代码，提高质量 JUnit是优雅简洁。它是不那么复杂以及不需要花费太多的时间。 JUnit测试可以自动运行，检查自己的结果，并提供即时反馈。没有必要通过测试结果报告来手动梳理。 JUnit测试可以组织成测试套件包含测试案例，甚至其他测试套件。 Junit显示测试进度的，如果测试是没有问题条形是绿色的，测试失败则会变成红色。 JUnit简单示例 使用工具：eclipse 测试类： Calculate.java public class Calculate { public int sum(int var1, int var2) { System.out.println(&quot;相加的值是: &quot; + var1 + &quot; + &quot; + var2); return var1 + var2; } } CalculateTest.java public class CalculateTest { Calculate calculation = new Calculate(); int sum = calculation.sum(2, 5); int testSum = 7; @Test public void testSum() { System.out.println(&quot;@Test sum(): &quot; + sum + &quot; = &quot; + testSum); assertEquals(sum, testSum); } } @Test的注解在 testSum()方法的上方。 这个注释指示该公共无效(public void)方法它所附着可以作为一个测试用例。因此，testSum()方法将用于测试公开方法 sum() 。 方法 assertEquals(sum, testsum)。assertEquals ([String message], object expected, object actual) 方法持有两个对象作为输入，并断言这两个对象相等。 如果要运行测试类，右键点击测试类，并选择 Run As -&gt; Junit Test。 JUnit注解在本节中，我们将提到支持在JUnit4基本注释，下表列出了这些注释的概括： 注解 描述@Testpublic void method() 测试注释指示该公共无效方法它所附着可以作为一个测试用例。@Beforepublic void method() Before注释表示，该方法必须在类中的每个测试之前执行，以便执行测试某些必要的先决条件。@BeforeClasspublic static void method()BeforeClass注释指出这是附着在静态方法必须执行一次并在类的所有测试之前。发生这种情况时一般是测试计算共享配置方法(如连接到数据库)。@Afterpublic void method()After 注释指示，该方法在执行每项测试后执行(如执行每一个测试后重置某些变量，删除临时变量等)@AfterClasspublic static void method()当需要执行所有的测试在JUnit测试用例类后执行，AfterClass注解可以使用以清理建立方法，(从数据库如断开连接)。注意：附有此批注(类似于BeforeClass)的方法必须定义为静态。@Ignorepublic static void method()当想暂时禁用特定的测试执行可以使用忽略注释。每个被注解为@Ignore的方法将不被执行。 让我们看看一个测试类，在上面提到的一些注解的一个例子。 AnnotationsTest.java package com.yiibai.junit; import static org.junit.Assert.*; import java.util.*; import org.junit.*; public class AnnotationsTest { private ArrayList testList; @BeforeClass public static void onceExecutedBeforeAll() { System.out.println(&quot;@BeforeClass: onceExecutedBeforeAll&quot;); } @Before public void executedBeforeEach() { testList = new ArrayList(); System.out.println(&quot;@Before: executedBeforeEach&quot;); } @AfterClass public static void onceExecutedAfterAll() { System.out.println(&quot;@AfterClass: onceExecutedAfterAll&quot;); } @After public void executedAfterEach() { testList.clear(); System.out.println(&quot;@After: executedAfterEach&quot;); } @Test public void EmptyCollection() { assertTrue(testList.isEmpty()); System.out.println(&quot;@Test: EmptyArrayList&quot;); } @Test public void OneItemCollection() { testList.add(&quot;oneItem&quot;); assertEquals(1, testList.size()); System.out.println(&quot;@Test: OneItemArrayList&quot;); } @Ignore public void executionIgnored() { System.out.println(&quot;@Ignore: This execution is ignored&quot;); } } 如果我们运行上面的测试，控制台输出将是以下几点： @BeforeClass: onceExecutedBeforeAll @Before: executedBeforeEach @Test: EmptyArrayList @After: executedAfterEach @Before: executedBeforeEach @Test: OneItemArrayList @After: executedAfterEach @AfterClass: onceExecutedAfterAll JUnit断言在本节中，我们将介绍一些断言方法。所有这些方法都受到 Assert 类扩展了java.lang.Object类并为它们提供编写测试，以便检测故障。下表中有一种最常用的断言方法的更详细的解释。 断言描述void assertEquals([String message], expected value, actual value)断言两个值相等。值可能是类型有 int, short, long, byte, char or java.lang.Object. 第一个参数是一个可选的字符串消息void assertTrue([String message], boolean condition)断言一个条件为真void assertFalse([String message],boolean condition)断言一个条件为假void assertNotNull([String message], java.lang.Object object)断言一个对象不为空(null)void assertNull([String message], java.lang.Object object)断言一个对象为空(null)void assertSame([String message], java.lang.Object expected, java.lang.Object actual)断言，两个对象引用相同的对象void assertNotSame([String message], java.lang.Object unexpected, java.lang.Object actual)断言，两个对象不是引用同一个对象void assertArrayEquals([String message], expectedArray, resultArray)断言预期数组和结果数组相等。数组的类型可能是 int, long, short, char, byte or java.lang.Object. 让我们看的一些前述断言的一个例子。 AssertionsTest.java package com.yiibai.junit; import static org.junit.Assert.*; import org.junit.Test; public class AssertionsTest { @Test public void test() { String obj1 = &quot;junit&quot;; String obj2 = &quot;junit&quot;; String obj3 = &quot;test&quot;; String obj4 = &quot;test&quot;; String obj5 = null; int var1 = 1; int var2 = 2; int[] arithmetic1 = { 1, 2, 3 }; int[] arithmetic2 = { 1, 2, 3 }; assertEquals(obj1, obj2); assertSame(obj3, obj4); assertNotSame(obj2, obj4); assertNotNull(obj1); assertNull(obj5); assertTrue(var1 var2); assertArrayEquals(arithmetic1, arithmetic2); } } 在以上类中我们可以看到，这些断言方法是可以工作的。 assertEquals() 如果比较的两个对象是相等的，此方法将正常返回；否则失败显示在JUnit的窗口测试将中止。 assertSame() 和 assertNotSame() 方法测试两个对象引用指向完全相同的对象。 assertNull() 和 assertNotNull() 方法测试一个变量是否为空或不为空(null)。 assertTrue() 和 assertFalse() 方法测试if条件或变量是true还是false。 assertArrayEquals() 将比较两个数组，如果它们相等，则该方法将继续进行不会发出错误。否则失败将显示在JUnit窗口和中止测试。 文章转载自：易百教程 [http:/www.yiibai.com]","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://mutouspace.cn/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://mutouspace.cn/tags/JAVA/"},{"name":"JUnit","slug":"JUnit","permalink":"http://mutouspace.cn/tags/JUnit/"}]},{"title":"JAVA学习之MySQL","slug":"JAVA学习之MySQL","date":"2017-03-21T13:52:33.000Z","updated":"2017-03-22T12:32:51.376Z","comments":true,"path":"2017/03/21/JAVA学习之MySQL/","link":"","permalink":"http://mutouspace.cn/2017/03/21/JAVA学习之MySQL/","excerpt":"本文主要记录MySQL数据库的简单使用。本部分记录了MySQL的安装、卸载，SQL语句的基础。 转载请注明：转载于Terry Tian的博客（www.mutouspace.cn）!","text":"本文主要记录MySQL数据库的简单使用。本部分记录了MySQL的安装、卸载，SQL语句的基础。 转载请注明：转载于Terry Tian的博客（www.mutouspace.cn）! 数据库概述数据库（DataBase，DB）：指长期保存在计算机的存储设备上，按照一定规则组织起来，可以被各种用户或应用共享的数据集合。(文件系统) 数据库管理系统（DataBase Management System，DBMS）：指一种操作和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制，以保证数据库的安全性和完整性。用户通过数据库管理系统访问数据库中的数据。 数据库软件应该为数据库管理系统，数据库是通过数据库管理系统创建和操作的。 数据库：存储、维护和管理数据的集合。 数据库的安装与配置安装与配置 卸载与修改密码卸载： 停止mysql服务 net stop mysql 启动mysql服务 net start mysql 卸载mysql 找到mysql 安装目录下的 my.ini datadir=”C:/ProgramData/MySQL/MySQL Server 5.5/Data/“ 修改密码 运行cmd 安装成功了打开cmd –&gt; mysql -uroot -p你的密码 修改mysql root用户密码 1) 停止mysql服务 运行输入services.msc 停止mysql服务 或者 cmd --&gt; net stop mysql 2) 在cmd下 输入 mysqld –skip-grant-tables 启动服务器 光标不动 （不要关闭该窗口） 3) 新打开cmd 输入mysql -u root -p 不需要密码 use mysql; update user set password=password(&apos;abc&apos;) WHERE User=&apos;root&apos;; 4) 关闭两个cmd窗口 在任务管理器结束mysqld 进程 5) 在服务管理页面 重启mysql 服务 密码修改完成 sql概述 SQL：Structure Query Language。（结构化查询语言） Sql的分类DDL（Data Definition Language）：数据定义语言，用来定义数据库对象：库、表、列等； CREATE、 ALTER、DROP DML（Data Manipulation Language）：数据操作语言，用来定义数据库记录（数据）； INSERT、 UPDATE、 DELETE DCL（Data Control Language）：数据控制语言，用来定义访问权限和安全级别； DQL（Data Query Language）：数据查询语言，用来查询记录（数据）。SELECT 注意：sql语句以;结尾 DDL:操作数据库、表、列等 使用的关键字：CREATE、 ALTER、 DROP example: CREATE TABLE emp ( id INT, NAME VARCHAR(50), gender VARCHAR(10), birthday DATE, entry_date DATE, job VARCHAR(100), salary DOUBLE, RESUME VARCHAR(200) ); -- 查看表的字段信息 DESC emp; -- 在emp TABLE中添加image列 ALTER TABLE emp ADD image BLOB; -- 修改job列，使其长度为60。 ALTER TABLE emp MODIFY job VARCHAR(60); -- 删除image列,一次只能删一列。 ALTER TABLE emp DROP image; -- 表名改为USER。 RENAME TABLE emp TO USER; -- 查看表格的创建细节 SHOW CREATE TABLE USER; -- 修改表的字符集为gbk ALTER TABLE USER CHARACTER SET gbk; -- 列名NAME修改为username ALTER TABLE USER CHANGE NAME username VARCHAR(100); DESC USER; -- 删除表 DROP TABLE USER ; DML操作(重要)插入操作：INSERT语法： INSERT INTO 表名（列名1，列名2 …）VALUES(列值1，列值2…);注意：列名与列值的类型、个数、顺序要一一对应。 可以把列名当做java中的形参，把列值当做实参。 值不要超出列定义的长度。 如果插入空值，请使用null 插入的日期和字符一样，都使用引号括起来。 练习 ： create table emp( id int, name varchar(100), gender varchar(10), birthday date, salary float(10,2), entry_date date, resume text ); INSERT INTO emp(id,name,gender,birthday,salary,entry_date,resume) VALUES(1,&apos;zhangsan&apos;,&apos;female&apos;,&apos;1990-5-10&apos;,10000,&apos;2015-5-5-&apos;,&apos;good girl&apos;); INSERT INTO emp(id,name,gender,birthday,salary,entry_date,resume) VALUES(2,&apos;lisi&apos;,&apos;male&apos;,&apos;1995-5-10&apos;,10000,&apos;2015-5-5&apos;,&apos;good boy&apos;); INSERT INTO emp(id,name,gender,birthday,salary,entry_date,resume) VALUES(3,&apos;wangwu&apos;,&apos;male&apos;,&apos;1995-5-10&apos;,10000,&apos;2015-5-5&apos;,&apos;good boy&apos;); -- 批量插入： INSERT INTO emp VALUES (4,&apos;zs&apos;,&apos;m&apos;,&apos;2015-09-01&apos;,10000,&apos;2015-09-01&apos;,NULL), (5,&apos;li&apos;,&apos;m&apos;,&apos;2015-09-01&apos;,10000,&apos;2015-09-01&apos;,NULL), (6,&apos;ww&apos;,&apos;m&apos;,&apos;2015-09-01&apos;,10000,&apos;2015-09-01&apos;,NULL); 修改操作 UPDATE语法：UPDATE 表名 SET 列名1=列值1，列名2=列值2 。。。 WHERE 列名=值 练习 ： -- 将所有员工薪水修改为5000元。 UPDATE emp SET salary=5000 -- 将姓名为’tom’的员工薪水修改为3000元。 UPDATE emp SET salary=3000 WHERE NAME=&apos;tom&apos;; -- 将姓名为’jerry’的员工薪水修改为4000元,gender改为female。 UPDATE emp SET salary=4000,gender=&apos;female&apos; WHERE NAME=&apos;jerry&apos;; -- 将蔡依林的薪水在原有基础上增加1000元。 UPDATE emp SET salary=salary+1000 WHERE NAME = &apos;蔡依林&apos;; 删除操作 DELETE语法 ： DELETE FROM 表名 【WHERE 列名=值】 练习 ： -- 删除表中名称为’zs’的记录。 DELETE FROM emp WHERE NAME=‘tom’; -- 删除表中所有记录。 DELETE FROM emp; -- 使用truncate删除表中记录。 TRUNCATE TABLE emp; DELETE 删除表中的数据，表结构还在;删除后的数据可以找回 TRUNCATE 删除是把表直接DROP掉，然后再创建一个同样的新表。 删除的数据不能找回。执行速度比DELETE快。 DQL操作 DQL数据查询语言 （重要）数据库执行DQL语句不会对数据进行改变，而是让数据库发送结果集给客户端。查询返回的结果集是一张虚拟表。 查询关键字：SELECT语法： SELECT 列名 FROM表名【WHERE –&gt; GROUP BY –&gt;HAVING–&gt; ORDER BY】 语法： SELECT selection_list /*要查询的列名称*/ FROM table_list /*要查询的表名称*/ WHERE condition /*行条件*/ GROUP BY grouping_columns /*对结果分组*/ HAVING condition /*分组后的行条件*/ ORDER BY sorting_columns /*对结果分组*/ LIMIT offset_start, row_count /*结果限定*/ 开始之前让我们先建几个表并插入数据 CREATE TABLE stu ( sid CHAR(6), sname VARCHAR(50), age INT, gender VARCHAR(50) ); INSERT INTO stu VALUES(&apos;S_1001&apos;, &apos;liuYi&apos;, 35, &apos;male&apos;); INSERT INTO stu VALUES(&apos;S_1002&apos;, &apos;chenEr&apos;, 15, &apos;female&apos;); INSERT INTO stu VALUES(&apos;S_1003&apos;, &apos;zhangSan&apos;, 95, &apos;male&apos;); INSERT INTO stu VALUES(&apos;S_1004&apos;, &apos;liSi&apos;, 65, &apos;female&apos;); INSERT INTO stu VALUES(&apos;S_1005&apos;, &apos;wangWu&apos;, 55, &apos;male&apos;); INSERT INTO stu VALUES(&apos;S_1006&apos;, &apos;zhaoLiu&apos;, 75, &apos;female&apos;); INSERT INTO stu VALUES(&apos;S_1007&apos;, &apos;sunQi&apos;, 25, &apos;male&apos;); INSERT INTO stu VALUES(&apos;S_1008&apos;, &apos;zhouBa&apos;, 45, &apos;female&apos;); INSERT INTO stu VALUES(&apos;S_1009&apos;, &apos;wuJiu&apos;, 85, &apos;male&apos;); INSERT INTO stu VALUES(&apos;S_1010&apos;, &apos;zhengShi&apos;, 5, &apos;female&apos;); INSERT INTO stu VALUES(&apos;S_1011&apos;, &apos;xxx&apos;, NULL, NULL); CREATE TABLE emp( empno INT, ename VARCHAR(50), job VARCHAR(50), mgr INT, hiredate DATE, sal DECIMAL(7,2), comm DECIMAL(7,2), deptno INT ) ; INSERT INTO emp VALUES(7369,&apos;SMITH&apos;,&apos;CLERK&apos;,7902,&apos;1980-12-17&apos;,800,NULL,20); INSERT INTO emp VALUES(7499,&apos;ALLEN&apos;,&apos;SALESMAN&apos;,7698,&apos;1981-02-20&apos;,1600,300,30); INSERT INTO emp VALUES(7521,&apos;WARD&apos;,&apos;SALESMAN&apos;,7698,&apos;1981-02-22&apos;,1250,500,30); INSERT INTO emp VALUES(7566,&apos;JONES&apos;,&apos;MANAGER&apos;,7839,&apos;1981-04-02&apos;,2975,NULL,20); INSERT INTO emp VALUES(7654,&apos;MARTIN&apos;,&apos;SALESMAN&apos;,7698,&apos;1981-09-28&apos;,1250,1400,30); INSERT INTO emp VALUES(7698,&apos;BLAKE&apos;,&apos;MANAGER&apos;,7839,&apos;1981-05-01&apos;,2850,NULL,30); INSERT INTO emp VALUES(7782,&apos;CLARK&apos;,&apos;MANAGER&apos;,7839,&apos;1981-06-09&apos;,2450,NULL,10); INSERT INTO emp VALUES(7788,&apos;SCOTT&apos;,&apos;ANALYST&apos;,7566,&apos;1987-04-19&apos;,3000,NULL,20); INSERT INTO emp VALUES(7839,&apos;KING&apos;,&apos;PRESIDENT&apos;,NULL,&apos;1981-11-17&apos;,5000,NULL,10); INSERT INTO emp VALUES(7844,&apos;TURNER&apos;,&apos;SALESMAN&apos;,7698,&apos;1981-09-08&apos;,1500,0,30); INSERT INTO emp VALUES(7876,&apos;ADAMS&apos;,&apos;CLERK&apos;,7788,&apos;1987-05-23&apos;,1100,NULL,20); INSERT INTO emp VALUES(7900,&apos;JAMES&apos;,&apos;CLERK&apos;,7698,&apos;1981-12-03&apos;,950,NULL,30); INSERT INTO emp VALUES(7902,&apos;FORD&apos;,&apos;ANALYST&apos;,7566,&apos;1981-12-03&apos;,3000,NULL,20); INSERT INTO emp VALUES(7934,&apos;MILLER&apos;,&apos;CLERK&apos;,7782,&apos;1982-01-23&apos;,1300,NULL,10); CREATE TABLE dept( deptno INT, dname VARCHAR(14), loc VARCHAR(13) ); INSERT INTO dept VALUES(10, &apos;ACCOUNTING&apos;, &apos;NEW YORK&apos;); INSERT INTO dept VALUES(20, &apos;RESEARCH&apos;, &apos;DALLAS&apos;); INSERT INTO dept VALUES(30, &apos;SALES&apos;, &apos;CHICAGO&apos;); INSERT INTO dept VALUES(40, &apos;OPERATIONS&apos;, &apos;BOSTON&apos;); 基础查询1.1 查询所有列 SELECT * FROM stu; 1.2 查询指定列 SELECT sid, sname, age FROM stu; 条件查询-- 查询性别为女，并且年龄&gt;=50的记录 SELECT * FROM stu WHERE gender=&apos;female&apos; AND age &gt;=50; -- 查询学号为S_1001，或者姓名为liSi的记录 SELECT * FROM stu WHERE sid =&apos;S_1001&apos; OR sname=&apos;liSi&apos;; -- 查询学号为S_1001，S_1002，S_1003的记录 SELECT * FROM stu WHERE sid IN (&apos;S_1001&apos;,&apos;S_1002&apos;,&apos;S_1003&apos;); -- 查询学号不是S_1001，S_1002，S_1003的记录 SELECT * FROM stu WHERE sid NOT IN (&apos;S_1001&apos;,&apos;S_1002&apos;,&apos;S_1003&apos;); -- 查询年龄为null的记录 SELECT * FROM stu WHERE age IS NULL; -- 查询年龄在20到40之间的学生记录 SELECT * FROM stu WHERE age&gt;=20 AND age&lt;=40; -- 或者 SELECT * FROM stu WHERE age BETWEEN 20 AND 40; -- 查询性别非男的学生记录 SELECT * FROM stu WHERE gender!=&apos;male&apos;; -- 或者 SELECT * FROM stu WHERE gender&lt;&gt;&apos;male&apos;; -- 或者 SELECT * FROM stu WHERE NOT gender=&apos;male&apos;; -- 查询姓名不为null的学生记录 SELECT * FROM stu WHERE sname IS NOT NULL; 模糊查询 当想查询姓名中包含a字母的学生时就需要使用模糊查询了。模糊查询需要使用关键字LIKE。 通配符: _ ：任意一个字符 % ：任意0~n个字符 Example: -- 查询姓名由5个字母构成的学生记录 SELECT * FROM stu WHERE sname LIKE &apos;_____&apos;; -- 模糊查询必须使用LIKE关键字。其中 “_”匹配任意一个字母，5个“_”表示5个任意字母。 -- 3.2 查询姓名由5个字母构成，并且第5个字母为“i”的学生记录 SELECT * FROM stu WHERE sname LIKE &apos;____i&apos;; -- 3.3 查询姓名以“z”开头的学生记录 SELECT * FROM stu WHERE sname LIKE &apos;z%&apos;; -- 其中“%”匹配0~n个任何字母。 -- 3.4 查询姓名中第2个字母为“i”的学生记录 SELECT * FROM stu WHERE sname LIKE &apos;_i%&apos;; -- 3.5 查询姓名中包含“a”字母的学生记录 SELECT * FROM stu WHERE sname LIKE &apos;%a%&apos;; 字段控制查询SELECT * FROM emp; -- 去除重复记录 SELECT DISTINCT deptno,mgr FROM emp; -- 查看雇员的月薪与佣金之和 SELECT * ,sal+comm FROM emp; -- 过滤null 并起别名 SELECT * ,sal+IFNULL(comm,0) AS total FROM emp; 排序 order by 列名 asc(默认) desc -- 查询所有学生记录，按年龄升序排序 SELECT * FROM stu ORDER BY age ASC; -- 查询所有学生记录，按年龄降序排序 SELECT * FROM stu ORDER BY age DESC; -- 查询所有雇员，按月薪降序排序，如果月薪相同时，按编号升序排序 SELECT * FROM emp ORDER BY sal DESC,empno ASC; 聚合函数 聚合函数是用来做纵向运算的函数： COUNT()：统计指定列不为NULL的记录行数； MAX()：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算； MIN()：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算； SUM()：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0； AVG()：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0； -- 查询emp表中记录数： SELECT COUNT(*) AS cnt FROM emp; -- 查询emp表中有佣金的人数： SELECT COUNT(comm) cnt FROM emp; -- 注意，因为count()函数中给出的是comm列，那么只统计comm列非NULL的行数。 -- 查询emp表中月薪大于2500的人数： SELECT COUNT(*) FROM emp WHERE sal &gt; 2500; -- 统计月薪与佣金之和大于2500元的人数： SELECT COUNT(*) AS cnt FROM emp WHERE sal+IFNULL(comm,0) &gt; 2500; -- 查询有佣金的人数，有领导的人数： SELECT COUNT(comm), COUNT(mgr) FROM emp; -- 查询所有雇员月薪和： SELECT SUM(sal) FROM emp; -- 查询所有雇员月薪和，以及所有雇员佣金和： SELECT SUM(sal), SUM(comm) FROM emp; -- 查询所有雇员月薪+佣金和： SELECT SUM(sal+IFNULL(comm,0)) FROM emp; -- 统计所有员工平均工资： SELECT AVG(sal) FROM emp; -- MAX和MIN -- 查询最高工资和最低工资： SELECT MAX(sal), MIN(sal) FROM emp; 分组查询 注：凡和聚合函数同时出现的列名，一定要写在group by 之后 -- 查询每个部门的部门编号和每个部门的工资和： SELECT deptno, SUM(sal) FROM emp GROUP BY deptno; -- 查询每个部门的部门编号以及每个部门的人数： SELECT deptno,COUNT(*) FROM emp GROUP BY deptno; -- 查询每个部门的部门编号以及每个部门工资大于1500的人数： SELECT deptno,COUNT(*) FROM emp WHERE sal&gt;1500 GROUP BY deptno; -- 查询工资总和大于9000的部门编号以及工资和： SELECT deptno, SUM(sal) FROM emp GROUP BY deptno HAVING SUM(sal) &gt; 9000; 注： having与where的区别: 1.having是在分组后对数据进行过滤. where是在分组前对数据进行过滤 2.having后面可以使用聚合函数(统计函数) where后面不可以使用聚合函数。 WHERE是对分组前记录的条件，如果某行记录没有满足WHERE子句的条件，那么这行记录不会参加分组；而HAVING是对分组后数据的约束。 LIMIT LIMIT用来限定查询结果的起始行，以及总行数。 -- 查询5行记录，起始行从0开始 SELECT * FROM emp LIMIT 0, 5; -- 查询10行记录，起始行从3开始 SELECT * FROM emp LIMIT 3, 10;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://mutouspace.cn/categories/数据库/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://mutouspace.cn/tags/JAVA/"},{"name":"MySQL","slug":"MySQL","permalink":"http://mutouspace.cn/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"http://mutouspace.cn/tags/数据库/"}]},{"title":"Git学习笔记系列","slug":"Git学习笔记系列","date":"2017-03-09T14:07:37.000Z","updated":"2017-03-10T11:37:04.436Z","comments":true,"path":"2017/03/09/Git学习笔记系列/","link":"","permalink":"http://mutouspace.cn/2017/03/09/Git学习笔记系列/","excerpt":"Git简介Git是什么？Git是目前世界上最先进的分布式版本控制系统（没有之一）。 Git有什么特点？简单来说就是：高端大气上档次！","text":"Git简介Git是什么？Git是目前世界上最先进的分布式版本控制系统（没有之一）。 Git有什么特点？简单来说就是：高端大气上档次！ 那什么是版本控制系统？ 如果你用Microsoft Word写过长篇大论，那你一定有这样的经历： 想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样： 过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。 看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。 更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。 于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？ 这个软件用起来就应该像这个样子，能记录每次文件的改动： 版本 用户 说明 日期 1 张三 删除了软件服务条款5 7/12 10:38 2 张三 增加了License人数限制 7/12 18:09 3 李四 财务部门调整了合同金额 7/13 9:51 4 张三 延长了免费升级周期 7/14 15:17 这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。 参考廖雪峰的网站：http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001373962845513aefd77a99f4145f0a2c7a7ca057e7570000 安装Git要使用Git，第一步当然是安装Git了。由于笔者使用的windows系统，所以此处只介绍在Windows环境下如何安装Git。 在Windows上安装Git 想要在Windows下安装Git，首先要下载Git安装包，用户可以从https://git-scm.com/download/下载，然后按默认选项安装即可。 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 安装完成后，还需要最后一步设置，在命令行输入： $ git config - -global user.name &quot;Your Name&quot; $ git config - -global user.email &quot;email@example.com&quot; 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。 注意: git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 创建版本库什么是版本库呢？ 版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录： $ mkdir tq1 $ cd tq1 注意：Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。 第二步，通过git init命令把这个目录变成Git可以管理的仓库： $ git init Initialized empty Git repository in F：/AndroidProject2/tq1/.git/ 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 把文件添加到版本库 现在我们编写一个readme.txt文件，内容如下： Git is a version control system. Git is free software. 一定要放到tq1目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 第一步，用命令git add告诉Git，把文件添加到仓库： $ git add readme.txt 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 第二步，用命令git commit告诉Git，把文件提交到仓库： $ git commit -m &quot;wrote a readme file&quot; [master (root-commit) cb926e7] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 嫌麻烦不想输入-m “xxx”行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。 git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如： $ git add file1.txt $ git add file2.txt file3.txt $ git commit -m &quot;add 3 files.&quot; 小结 现在总结一下今天学的两点内容： 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 第一步，使用命令git add ，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit，完成。 远程仓库到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。 可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。 没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：远程仓库。 Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。 你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？ 其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。 实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。 完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫Coding的神奇的网站，这个网站就是提供Git仓库托管服务的，所以，只要注册一个Coding账号，就可以免费获得Git远程仓库。 在继续阅读后续内容前，请自行注册Coding账号。由于你的本地Git仓库和Coding仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆Coding，打开“设置”，“部署公钥”页面： 然后，点“新建部署公钥”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： 点“添加”，你就应该看到已经添加的Key： 为什么Coding需要SSH Key呢？因为Coding需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，Coding只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，Coding允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到Conding，就可以在每台电脑上往Coding推送了。 最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。 确保你拥有一个Coding账号后，我们就即将开始远程仓库的学习。 添加远程库现在的情景是，你已经在本地创建了一个Git仓库后，又想在Coding创建一个Git仓库，并且让这两个仓库进行远程同步，这样，Coding上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 首先，登陆Coding，然后，在右上角的“+”找到“项目”按钮，创建一个新的仓库： 在 项目名称 填入tq1，其他保持默认设置，点击“创建项目”按钮，就成功地创建了一个新的Git仓库，目前，在Coding的这个tq1仓库还是空的，点击左侧“代码”选项： Coding告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到Coding仓库。 现在，我们根据Coding的提示，在本地的tq1仓库下运行命令： git remote add origin git@git.coding.net:Mu_TQ/tq1.git 请千万注意，把上面的Mu_TQ替换成你自己的Coding账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上： $ git push -u origin master Counting objects: 19, done. Delta compression using up to 4 threads. Compressing objects: 100% (19/19), done. Writing objects: 100% (19/19), 13.73 KiB, done. Total 23 (delta 6), reused 0 (delta 0) To git@github.com:michaelliao/learngit.git * [new branch] master -&gt; master Branch master set up to track remote branch master from origin. 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样： 从现在起，只要本地作了提交，就可以通过命令： $ git push origin master 把本地master分支的最新修改推送至Coding，现在，你就拥有了真正的分布式版本库！ SSH警告 当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告： The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established. RSA key fingerprint is xx.xx.xx.xx.xx. Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了： Warning: Permanently added &apos;github.com&apos; (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。 如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。 小结 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！","categories":[{"name":"教程","slug":"教程","permalink":"http://mutouspace.cn/categories/教程/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://mutouspace.cn/tags/Git/"}]},{"title":"软件分享篇（Windows10）","slug":"软件分享篇","date":"2017-03-06T14:00:41.899Z","updated":"2017-03-02T15:28:16.622Z","comments":true,"path":"2017/03/06/软件分享篇/","link":"","permalink":"http://mutouspace.cn/2017/03/06/软件分享篇/","excerpt":"今晚有点晚了，就不撸代码了，决定把我电脑里常用的软件、工具分享给大家，这些软件真的很好用，不信你可以试一试！ 转载请注明：转载于Terry Tian的博客（www.mutouspace.cn）!","text":"今晚有点晚了，就不撸代码了，决定把我电脑里常用的软件、工具分享给大家，这些软件真的很好用，不信你可以试一试！ 转载请注明：转载于Terry Tian的博客（www.mutouspace.cn）! 安全杀毒： TT电脑里用的杀毒防护软件是Windows系统自带的Windows Defender，说实话，现在Windows自带的杀软已经很好了，具体好到哪，大家可以自行百度、google。软件界面简单、实用，还没有广告，界面如下： 清理软件我用的是口碑很好的 CCleaner,功能完全足够你使用了！截图如下： 对于非一般的用户，特别是计算机专业的学生，真的不是很建议在电脑了安装些安全卫士、管家、毒霸等软件的！ 开发工具 Android Studio：对于这款软件大家一定都不陌生，特别是对于一位安卓开发人员，Google的亲儿子，好好享受吧！ eclipse：一款插件丰富的开发工具，java开发者用的挺多，以前也用于开发安卓，可惜Google生了个儿子。 SQLite Expert Personal：一款可以查看数据表中数据的软件，安卓开发人员都值得拥有！ 系统工具 chrome：好用的不能再好用的浏览器。插件丰富，但需要科学上网。 缺点就是在国内没法云备份自己的收藏夹。推荐大家可以在安装一款360极速浏览器、或者QQ浏览器来备份自己的收藏夹。 MarkdownPad 2：我认为这可能是Windows系统下最好用的markdown书写软件了，可以去官网下载。 Seer:是一款 Windows 下的文件预览工具，可以无需打开图片、音乐、视频、压缩包等文件就能预览到内容，只需点一下空格。下载地址：http://www.appinn.com/seer-windows/。 护眼宝：是一款护眼的工具，下载地址：http://www.huyanbao.com/#top。 Clover:Clover 是 Windows Explorer 资源管理器的一个扩展，为其增加类似谷歌 Chrome 浏览器的多标签页功能。 ADSafe：ADSafe是一款好用的广告屏蔽软件！ HoneyView:HoneyView是一个支持多种格式的极速图像浏览器。 她同时支持不解压浏览ZIP、RAR和7z压缩包中的图片。 她可以显示图片的GPS信息并在Google Maps中查看该地点，同时用户可以储存喜爱的照片。 影音工具 网易云音乐（UWP）：逼格漫漫的音乐播放器。 Potplayer：PotPlayer诚意满满的视频播放器。 下载工具 IDM：Internet Download Manager(简称“IDM”)是国外的一款下载工具，提升你的下载速度最多达5倍，安排下载时程，或续传一半的软件。Internet Download Manager的续传功能可以恢复因为断线、网络问题、计算机当机甚至无预警的停电导致下传到一半的软件。 EagleGet:EagleGet（亦称 EG Download Accelerator）是一个用于 Windows 系统的下载管理器，它是免费软件。EagleGet 使用多线程技术，支持从Youtube、Dailymotion、Facebook、Vimeo等视频网站下载 MP4 和 FLV 格式视频。EagleGet 是一个拥有简洁界面和功能的免费的新下载管理器。 迅雷：国内用户电脑中常备的下载软件，大多数网站也都支持迅雷下载。但我真的越来越讨厌迅雷了，不仅下载速度限速，界面也越来越复杂，广告还多，越来越丧失了一款下载软件的本心。 分享到这里就结束了，如果大家有什么疑问可以留言，有好的软件推荐给我，也可以留言，谢谢阅读！","categories":[{"name":"分享","slug":"分享","permalink":"http://mutouspace.cn/categories/分享/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://mutouspace.cn/tags/分享/"}]},{"title":"胡歌为什么会有今天的高度？","slug":"胡歌为什么会有今天的高度？","date":"2017-02-19T04:31:07.000Z","updated":"2017-02-19T04:32:16.015Z","comments":true,"path":"2017/02/19/胡歌为什么会有今天的高度？/","link":"","permalink":"http://mutouspace.cn/2017/02/19/胡歌为什么会有今天的高度？/","excerpt":"strong a { color: #747474; } .player { text-align: center; margin: .5em auto 0; width: 100%; max-width: 22em; } .player br { display: none; } .sign { text-align: right; font-style: italic; } #ds-recent-visitors { margin: 0; padding: 0; } #ds-recent-visitors div img { display: inline-block !important; width: 56px !important; height: 56px !important; border-radius: 50%; border: 1px solid #ddd; padding: 2px; box-shadow: 1px 1px 1px rgba(0,0,0, .15); } .article-entry img:first-child { display: block; } .article-entry span { font-family: Arial; } #ds-hot-posts { display: none; } 本文转载于微信公众号：小林分享 藏书如山积，读书如水流。山形有限度，水流无时休。 —— Terry_Tian, 2017年2月19日 在娱乐圈里，想通过大荧幕红透半边天的人有很多。 但能够沉下心，通过学习和阅读来提升自己的不多。 胡歌算一个。","text":"strong a { color: #747474; } .player { text-align: center; margin: .5em auto 0; width: 100%; max-width: 22em; } .player br { display: none; } .sign { text-align: right; font-style: italic; } #ds-recent-visitors { margin: 0; padding: 0; } #ds-recent-visitors div img { display: inline-block !important; width: 56px !important; height: 56px !important; border-radius: 50%; border: 1px solid #ddd; padding: 2px; box-shadow: 1px 1px 1px rgba(0,0,0, .15); } .article-entry img:first-child { display: block; } .article-entry span { font-family: Arial; } #ds-hot-posts { display: none; } 本文转载于微信公众号：小林分享 藏书如山积，读书如水流。山形有限度，水流无时休。 —— Terry_Tian, 2017年2月19日 在娱乐圈里，想通过大荧幕红透半边天的人有很多。 但能够沉下心，通过学习和阅读来提升自己的不多。 胡歌算一个。 去读书，是他多年想做而不得做的事。 时光悄然流逝，从曾经的少年心性，到如今的睿智成熟。 胡歌唯一没变的，就是对学习的向往。 甚至决定为了深造的事宜，暂时息影两年。 其实，这个决定早就有端倪，春晚结束后有媒体采访胡歌，他说：“2017年将作为自己的学习阶段，继续深造。” 果然，不久之后，就有人在美国大使馆相逢正在办理签证的胡歌，也有人在机场拍下这张照片。 手里抱着书，翘着二郎腿，身旁时贴满行李条的行李箱和背包，内心却是“独钓寒江雪”的怡然自得。 2005年，胡歌因为成功塑造了电视剧《仙剑奇侠传》中豪爽深情的“李逍遥”一角而成名，迅速跻身“四大小生”头列，广告签约不断，无数粉丝热捧。 原本蓄力满满，却一瞬跌入谷底。 2006年，胡歌和助理乘坐的汽车突然和另一货车发生碰撞，助理当场死亡，胡歌也遭遇重创。 那段时间，是胡歌有记忆的人生里最痛苦的岁月。 为了让自己振作起来，胡歌开始大量的阅读，写专栏。 在这篇题为《照镜子》的专栏中，胡歌写： 车祸创伤了我的容貌，也冲击了我的内心。 每次当我战战兢兢拿起镜子的时候，我都渴望能在镜子里寻找到勇气和力量。 镜子的语言简洁而充满了智能，除了我自己，没有人能够让我真正重新站立。 如果皮囊难以修复，就用思想去填满它吧。 嗯，用思想慢慢填充皮囊。 他开始摄影、参与公益，等待伤口被修复，也等待被击垮的自信重新建立起来。 丢了少年容颜，拾得一个更广阔的世界，在书里，安心的当自己的主演。 2007年6月22日，胡歌宣布复出。 重回大众视线的胡歌，与车祸之前相比，脸上多了几许忧郁。 为了遮盖自己右眼的伤疤，他全程带着黑框眼镜。 在拍仙三的时候，也用头发遮住自己手上的眼骨，可眼神里却是历经爱恨生死之后的沧桑。 从那之后，他旅行、阅读、修复容貌…… 2015年，带着饱满思想回归的胡歌，强势推出了《琅琊榜》和《伪装者》两部作品，重新回归大众视野。 也被很多人调侃说，二红。 彼时，他深陷磨难，几度忧伤和消沉。 此时，他褪去青涩，愈加真实和沉稳。 如今，胡歌是娱乐圈公认的高情商，阅读塑造了他严密的思维逻辑，也让他在浮躁复杂的娱乐圈里，游走自如。 2016年白玉兰颁奖典礼上，胡歌成为该奖项的首个80后视帝。 台下坐着无数前辈，更让人为难的是，私下最好的朋友，也是竞争对手的大哥靳东，也在台下坐着，主持人主动挑起话题： 拿到视帝的胡歌想对靳东说点什么呢？ 胡歌的回应就很棒： 在戏里我们是家人，戏外我们也是家人，这个奖项不管谁拿都是咱家的。我刚和敏涛姐说，不管是谁拿了奖，这个奖都是挂在咱们家的墙上。 没有人会好运一辈子，也许生命中那些独自隐忍的时刻，就是让一个人更接近自己的机会。 胡歌在阅读里得到新生、填补灵魂，给了我们对于“阅读的意义”最好诠释： 阅读是为了让我们更好的认识自己，成为更好的自己。","categories":[{"name":"美文","slug":"美文","permalink":"http://mutouspace.cn/categories/美文/"}],"tags":[{"name":"美文","slug":"美文","permalink":"http://mutouspace.cn/tags/美文/"},{"name":"杂记","slug":"杂记","permalink":"http://mutouspace.cn/tags/杂记/"},{"name":"转载","slug":"转载","permalink":"http://mutouspace.cn/tags/转载/"}]},{"title":"使用Hexo+github建设个人博客教程","slug":"使用Hexo-github建设个人博客教程","date":"2017-02-18T07:46:58.000Z","updated":"2017-02-19T03:21:32.577Z","comments":true,"path":"2017/02/18/使用Hexo-github建设个人博客教程/","link":"","permalink":"http://mutouspace.cn/2017/02/18/使用Hexo-github建设个人博客教程/","excerpt":"前言博主本来打算在Coding上搭建自己的Ghost博客，由于以前没有搭建博客的经验，就在网上百度教程，但很遗憾，教程很少，写的也比较简单，最终在别人的推荐下，选择了Hexo搭建静态博客。 教程思路： 列出博客搭建环境+所需工具； 环境的配置与工具的安装简述，以及简单的使用教程，安装Git、Node.js环境以及Hexo框架； 创建Hexo项目，并本地运行查看效果 修改项目配置文件（根目录下的_config.yml文件） 安装Hexo框架主题（推荐：Next或yelee主题，本人用的yelee），对主题进行配置，主要是修改theme目录下的_config.yml文件 将本地设置好的Hexo项目发布到Github Pages上（包括绑定自己的域名）（这里会介绍如何写文章） 总结","text":"前言博主本来打算在Coding上搭建自己的Ghost博客，由于以前没有搭建博客的经验，就在网上百度教程，但很遗憾，教程很少，写的也比较简单，最终在别人的推荐下，选择了Hexo搭建静态博客。 教程思路： 列出博客搭建环境+所需工具； 环境的配置与工具的安装简述，以及简单的使用教程，安装Git、Node.js环境以及Hexo框架； 创建Hexo项目，并本地运行查看效果 修改项目配置文件（根目录下的_config.yml文件） 安装Hexo框架主题（推荐：Next或yelee主题，本人用的yelee），对主题进行配置，主要是修改theme目录下的_config.yml文件 将本地设置好的Hexo项目发布到Github Pages上（包括绑定自己的域名）（这里会介绍如何写文章） 总结 准备工作在搭建博客时，你需要做以下准备： 确定自己的系统为Windows;(因为博主用的系统是Windows10，为了避免浪费您的时间，如果不是Windows系统就不要看了。) Git下载，node.js下载。 本文所使用的环境： Windows 10 Git version 2.11.1.windows.1 node.js v6.9.5 LTS hexo 开始搭建博客Git下载安装及简单实用为什么要在电脑上安装Git呢？我相信大多计算机专业的同学对Git的应该不陌生了，Git可以说是现如今最好用的、最先进的分布式版本控制系统（没有之一）。Git在接下来的环境部署及部署博客到github Pages时都是需要的。大家如果有兴趣可以阅读我的博客（Git的简单使用），对Git进行简单的了解。如果了解Git也没有关系，只要你按照教程一步一步来也可以。 下载Git 我们可以在Git的官网下载我们所需要的git，我选择的是最新版的Git Windows X64 版本。 安装Git Git的安装也很简单，就像安装我们平时所需要的软件一样，教程参考：Git的安装。 Git的简单实用 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 第一步，使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit，完成。 我们在这里不太需要git的命令操作，一般只需要git的的shell窗口进行一些操作。 node.js的下载安装下载 打开 Nodejs 下载页面，选择合适你当前系统版本的安装包（建议使用 LTS 版本的）。 安装 双击安装文件 -&gt; 下一步 -&gt; 下一步… 【具体操作请参考网上的一篇文章：Node.js安装及环境配置之Windows篇】 Hexo框架的安装首先我们可以看一下hexo的官网，了解一下hexo。 Windows中的安装 打开命令行 Win+R或者点击开始按钮–&gt;运行–&gt;输入“cmd”; 用 Git Bash 输入命令 npm install hexo-cli -g 输入完命令后就开始了hexo的安装，这里可能需要等待一段时间，时间不确定，只要不报错就可以了。 创建Hexo本地博客 接下来我们在一个本地盘自定义路径中创建一个文件夹作为我的项目文件，我在这里选择了在G盘下新建了一个名为TerryBlog的文件夹，作为我的项目文件，路径为【G:\\TerryBlog】.在G盘下，点击鼠标右键–&gt;Git Bash，打开命令输入框。输入命令如下： hexo init TerryBlog //hexo init +你的项目名称，如我的为TerryBlog 执行完上述命令后，我们就创建了TerryBlog文件夹，进入刚创建的TerryBlog项目目录，命令操作如下： cd TerryBlog //进入TerryBlog目录 或者直接在TerryBlog文件夹下，再点击鼠标右键–&gt;Git Bash，打开命令输入框。再输入以下命令： npm install 安装完成之后，【G:\\TerryBlog】目录结构是这样的： 到此为止，一个博客就已经搭建好了，现在我们启动 hexo 本地服务，看下默认的博客是怎样的，命令如下： hexo s 在浏览器中输入：http://localhost:4000/进行访问，效果图如下： ** 如果要停止 hexo 服务：在 Git Bash 下按 Ctrl + C即可** 到这里我们简单的hexo博客基本就完成一部分了！是不是很开心，如果不进行主题美化的话，我们马上就可以有一个自己的博客了。 修改项目配置文件 在这里我们修改的是【G:\\TerryBlog】路径下的 _config.yml 站点主题配置文件，我的配置如下： 注意：修改之前最好备份一下。 # Hexo Configuration ## Docs: https://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site 这一块区域主要是设置博客的主要说明，需要注意的是：每个冒号后面都是有一个空格，然后再书写自己的内容的 title: Terry_Tian Code #网站标题 subtitle: 行是知之始 知是行之成 #网站副标题 description: 在山的这边，海的那边，有一只程序猿。。。 #描述 author: Terry Tian #博主名字 avatar: http://olg3gwtbm.bkt.clouddn.com/head.jpg #博主头像 email: 1015236187@qq.com #邮箱 language: zh-Hans #语言 timezone: #网站时区。Hexo默认使用电脑时区 # URL,这一块一般可以设置的是 url 这个参数，比如我要设置绑定域名的，这里就需要填写我的域名信息 ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: http://mutouspace.cn/ root: / permalink: :year/:month/:day/:title/ permalink_defaults: # Directory source_dir: source public_dir: public tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render: # Writing new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true auto_detect: false tab_replace: # Category &amp; Tag default_category: uncategorized category_map: tag_map: # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination ## Set per_page to 0 to disable pagination per_page: 10 pagination_dir: page # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: yelee # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: git@github.com:MuTouTQ/MuTouTQ.github.io.git branch: master search: path: search.xml field: post 做完这一些之后再在Git Bash 命令框中，输入 hexo s 重新启动服务，在浏览器中输入：http://localhost:4000/进行访问,查看一下效果。 安装Hexo框架主题 在上一步完成后，你会发现虽然改了一部分配置，但页面还是很吃藕，接下来，咱们就要给咱们的博客美美容了。hexo的主题有很多，大家可以去这里选一下，hexo-theme：https://hexo.io/themes/. 我选择的是yelee主题：yelee 还是让 Git Bash 保持在【G:\\TerryBlog】目录下，然后输入命令： git clone https://github.com/MOxFIVE/hexo-theme-yelee.git themes/yelee 这样就在 【G:\\TerryBlog\\themes】目录下生成了一个 yelee 文件夹，里面有我们刚刚 clone 下来的主题内容。 我们现在要修改【G:\\TerryBlog】目录下的项目配置文件：_config.yml，把对应的主题目录名改下，主要是将配置中的 theme: yelee修改。 注意：该配置文件中的键值之间一定要有空格，否则轻则没有作用，重则报错，无法启动。 更改主题目录名后，我们还要重新生成主题静态内容，继续在 Git Bash 中输入命令输入如下命令： hexo g //重新生成静态博客的所有内容 hexo s //重启 hexo 本地服务 重新访问：http://localhost:4000/，看一下效果. 修改Hexo框架主题 上一步完成后，看到的是yelee的默认主题，这里我们可以再次配置一下，修改的是【G:\\TerryBlog\\themes\\yelee】路径下的 _config.yml文件。这里我们可以跟着Yelee 主题使用说明来修改。 发布到Github Pages上创建Github Pages并SSH授权 现在假设你已经有一个 Gtihub 账号，你还需要一个特别的仓库，特别在仓库名就是你的 Github 账号登录名，比如我的用户名是：MuouTQ，那我要创建的仓库名字完整滴填写是：MuouTQ.github.io，具体效果如下图： 仔细的人可能看到，你的仓库名根本不和你的用户名一样，由于我之前已经创建了一个这样特别的仓库，再创建一个就会提示错误，为了演示方便，所以删了一个T。 创建好仓库之后，要本地生成 SSH 秘钥，方便电脑上的 git 软件好提交内容到 Github 上。 【具体可以参考网上的一篇文章：Git安装及SSH Key管理之Windows篇】 现在用记事本打开公钥，复制文件中的所有内容。访问：https://github.com/settings/ssh， Title：自己随便取 Key：把刚刚复制的都粘贴进来 把本地的博客内容同步到 Github 上 要把本地的静态博客同步到 Github，我们还需要先安装两个跟部署相关的 hexo 插件： cd G:\\TerryBlog //进入TerryBlog项目目录 上一步，我们可以到 G:\\TerryBlog 路径下 Git Bash 一下； npm/cnpm install hexo-server --save //创建 npm/cnpm install hexo-deployer-git --save //安装自动部署发布工具 编辑TerryBlog的项目配置文件：_config.yml 官网对此配置的介绍：https://hexo.io/zh-cn/docs/configuration.html 主要改这里（一般在最后面）： # Deployment ## 这里是重点，这里是修改发布地址，因为我们前面已经加了 SSH 密钥信息在 Github 设置里面了，所以只要我们电脑里面持有那两个密钥文件就可以无需密码地跟 Github 做同步。 ## 需要注意的是这里的 repo 采用的是 ssh 的地址，而不是 https 的。分支我们默认采用 master 分支，以后你翅膀硬了要换其他也无所谓。 ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: git@github.com:MuTouTQ/MuTouTQ.github.io.git branch: master 编辑完项目配置文件后我们需要重新部署： cd G:\\TerryBlog //进入TerryBlog项目目录 上一步，我们可以到 G:\\TerryBlog 路径下 Git Bash 一下； hexo clean//先清除掉已经生成的旧文件 hexo g //再生成一次静态文件 hexo s //在本地预览下 hexo d //本地没问题之后，Ctrl + C 停掉本地预览，使用部署命令部署到 Github 上 访问服务器地址进行检查：http://MuTouTQ.github.io/，该访问地址是之前在github上的创建的仓库名称，输入你的github用户名 + .github.io 绑定域名 创建CNAME文件 我们要一个 CNAME 文件（文件名叫 CNAME，文件没有后缀，里面的内容为你购买的域名，不要以http以及www等前缀，只需域名本身即可，如：mutouspace.cn。这个CNAME可以你先建一个txt文件，把后缀名去掉），把该文件放在 G:\\TerryBlog 目录下。 获取Github的ip地址 实际获取的是你github上博客项目的ip（即：MuTouTQ.github.io），打开命令窗口，输入【ping MuTouTQ.github.io】来查看ip地址，并记录下来 添加DNS Service记录 我的域名是腾讯云上买的，用的腾讯云的域名解析，将ip地址和你买的域名绑定就好了，域名解析后需要等待几分钟才能被访问 补充： 如果你做完域名解析后，还是没法用你的域名访问，可以这项修改下： 打开你的Git Hub下的MuTouTQ.github.io仓库，找到Settings，点进去 点进去后，找到这里，填入你的域名：mutouspace.cn 点击：SAVE 等一会就可以访问了。 到此为止，我们的博客就成功配置完了！ 发表一篇文章 在G:\\TerryBlog 路径下Git Bash执行命令： hexo new &quot;my new post&quot; 在G:\\TerryBlog\\source_post中打开my-new-post.md，打开方式使用记事本或notepad++（推荐：MarkdownPad）。 hexo中写文章使用的是Markdown，没接触过的可以看下Markdown语法说明. title: my new post #可以改成中文的，如“新文章” date: 2015-04-08 22:56:29 #发表日期，一般不改动 categories: blog #文章文类 tags: [博客，文章] #文章标签，多于一项时用这种格式，只有一项时使用tags: blog #这里是正文，用markdown写，你可以选择写一段显示在首页的简介后，加上 #在之前的内容会显示在首页，之后的内容会被隐藏，当游客点击Read more才能看到。 写完文章后，你可以使用1. hexo g生成静态文件。2. hexo s在本地预览效果。3.hexo d同步到github，然后使用mutouspace.cn进行访问。 总结常用hexo命令常见命令 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 缩写： hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 组合命令： hexo s -g #生成并本地预览 hexo d -g #生成并上传 最终效果 可以访问我的git博客来查看效果： mutouspace.cn 参考 基于Hexo+Github Pages的博客搭建 使用Hexo搭建个人博客(基于hexo3.0) 使用hexo+github搭建免费个人博客详细教程","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://mutouspace.cn/categories/Hexo/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://mutouspace.cn/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"http://mutouspace.cn/tags/Hexo/"},{"name":"node","slug":"node","permalink":"http://mutouspace.cn/tags/node/"},{"name":"github","slug":"github","permalink":"http://mutouspace.cn/tags/github/"}]},{"title":"测试二","slug":"测试二","date":"2017-02-17T11:51:30.000Z","updated":"2017-02-17T13:18:19.296Z","comments":true,"path":"2017/02/17/测试二/","link":"","permalink":"http://mutouspace.cn/2017/02/17/测试二/","excerpt":"","text":"","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"http://mutouspace.cn/tags/测试/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-02-17T11:51:30.000Z","updated":"2017-03-06T14:14:31.510Z","comments":true,"path":"2017/02/17/hello-world/","link":"","permalink":"http://mutouspace.cn/2017/02/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://mutouspace.cn/tags/Hexo/"}]},{"title":"测试一","slug":"测试一","date":"2017-02-17T11:44:07.000Z","updated":"2017-02-18T05:29:46.604Z","comments":true,"path":"2017/02/17/测试一/","link":"","permalink":"http://mutouspace.cn/2017/02/17/测试一/","excerpt":"#这里是正文，用markdown写，你可以选择写一段显示在首页的简介后，加上","text":"#这里是正文，用markdown写，你可以选择写一段显示在首页的简介后，加上 #在之前的内容会显示在首页，之后的内容会被隐藏，当游客点击Read more才能看到。","categories":[{"name":"测试","slug":"测试","permalink":"http://mutouspace.cn/categories/测试/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://mutouspace.cn/tags/测试/"}]}]}